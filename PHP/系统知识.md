# 大纲列表

## MySQL 
1、一条SQL查询语句是如何执行的？如果查询不存在的字段，是在哪个阶段报的错？

2、每天一千万订单，要求用户查自己的订单，商家查自己家的订单，怎么设计订单表？

3、MySQL的事务隔离级别是什么?

4、MySQL有哪几种锁机制，每种锁都做了些什么？

5、为什么MySQL的索引要使用B+树，而不是其它树？比如B树？

6、什么是数据库设计的三大范式？范式设计和反范式设计的优缺点？

7、MySQL中 MyISAM 与 InnoDB 的区别，至少5点？

8、MySQL中 VARCHAR 与 CHAR 的区别以及 VARCHAR(50) 中的50代表的涵义？int(20)中20的涵义？

9、 InnoDB 的事务与日志的实现方式？

10、MySQL数据库 CPU 飙升到500%的话怎么处理？

11、Explain 执行计划包含的字段及说明？

12、什么是索引？MySQL 索引都有哪些类型？索引的优缺点是什么？

13、




## PHP
1、PHP如何解决网站大流量和高并发的问题？

2、PHP底层的运行机制与原理？

3、什么是CGI、FastCGI、PHP-CGI、PHP-FPM?

4、合并两个有序数组。 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

## Redis
1、Redis 的 Hash 怎么实现的?



## Linux





## 网络





## 安全





## 设计模式





## 数据结构



## 算法



## 架构篇



## 其他

1、如何设计一个秒杀系统？

2、如何避免超卖？





# MySQL

1、 一条SQL查询语句是如何执行的？如果查询不存在的字段，是在哪个阶段报的错？

[基础架构：一条SQL查询语句是如何执行的？](https://time.geekbang.org/column/article/115537)

![img](系统知识.assets/0d2070e8f84c4801adbfa03bda1f98d9.png)

SQL执行流程：

① 第一步，首先会通过连接器先连接到数据库上。连接器负责跟客户端建立连接、获取权限、维持和管理连接。

② 第二步，会到查询缓存中查询之前是否有缓存结果，命中则直接返回结果。

③  第三步，对 SQL 语句做解析，分析器先会做“词法分析”，接着做语法分析，根据语法规则判断这个 SQL 语句是否满足 MySQL 语法。

④ 第四步，接着优化器对 SQL 语句做优化分析，多索引时决定使用哪个索引，多表关联时决定表的连接顺序，最终确定执行计划方案。

⑤ 第五步，执行器执行阶段，先判断查询或更新权限的验证，如果有权限打开表调用引擎提供的接口进行执行，获取结果。

不存在字段的判断阶段：

Oracle 会在分析阶段判断语句是否正确，表是否存在，列是否存在等。

MySQL 在进行解析器处理时会生成一棵对应的解析树，预处理器进一步检查解析树的合法。比如：数据表和数据列是否存在，别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。

2、每天一千万订单，要求用户查自己的订单，商家查自己家的订单，怎么设计订单表？

分库分表。数据库分表可以解决单表海量数据的查询性能问题，分库可以解决单台数据库的并发访问压力问题。

分库分表主要是为了用户端下单和查询使用，按user_id的查询频率最高，其次是order_id。所以我们选择user_id做为sharding column，按user_id做hash，将相同用户的订单数据存储到同一个数据库的同一张表中。这样用户在网页或者App上查询订单时只需要路由到一张表就可以获取用户的所有订单了，这样就保证了查询性能。

另外我们在订单ID（order_id）里掺杂了用户ID（user_id）信息。简单来说，order_id的设计思路就是，将order_id分为前后两部分，前面的部分是user_id，后面的部分是具体的订单编号，两部分组合在一起就构成了order_id。这样我们很容易从order_id解析出user_id。通过order_id查询订单时，先从order_id中解析出user_id，然后就可以根据user_id路由到具体的库表了。

另外，数据库分成16个，每个库分16张表还有一个好处。16是2的N次幂，所以hash值对16取模的结果与hash值和16按位“与运算”的结果是一样的。我们知道位运算基于二进制，跨过各种编译和转化直接到最底层的机器语言，效率自然远高于取模运算。

查询直接查数据库，会不会有性能问题？是的。所以我们在上层加了Redis，Redis做了分片集群，用于存储活跃用户最近50条订单。这样一来，只有少部分在Redis查不到订单的用户请求才会到数据库查询订单，这样就减小了数据库查询压力，而且每个分库还有两个从库，查询操作只走从库，进一步分摊了每个分库的压力。



3、MySQL的事务隔离级别是什么？

[【MySQL 知识】四种事务隔离级别](https://wwxiong.com/?p=219)

[事务隔离：为什么你改了我还看不见？](https://time.geekbang.org/column/article/68963)

* 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。

* 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
* 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
* 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

![image-20210319151349090](系统知识.assets/image-20210319151349090.png)

4、MySQL有哪几种锁机制，每种锁都做了些什么？

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁、页级锁。

* 全局锁就是对整个数据库实例加锁，全局加锁会让整个库处于只读状态，此后其他线程的语句都会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是，做全库逻辑备份。MySQL 加全局读锁的方法，命令是` Flush tables with read lock (FTWRL)`。
* 表级锁是对整张表进行加锁，这种锁的方式粒度大，优点是开销小，加锁快；缺点是发生锁冲突的概率最高，并发度最低，MYISAM只支持表锁。
* 行级锁是对当前操作的行进行加锁，是MySQL中锁定粒度最细的一种锁，优点是锁定粒度最小，发生锁冲突的概率最低，并发度也最高；缺点是开销大，加锁慢；会出现死锁。
* 页级锁是MySQL中**锁定粒度介于行级锁和表级锁中间的一种锁**，特点是开销和加锁时间界于表锁和行锁之间；锁定粒度界于表锁和行锁之间，并发度一般，会出现死锁。

5、为什么MySQL的索引要使用B+树，而不是其它树？比如B树？

[MySQL 高频面试题 - 为什么 B+ 树比 B 树更适合应用于数据库索引？](https://leetcode-cn.com/circle/discuss/F7bKlM/)

[面试官问你B树和B+树，就把这篇文章丢给他](https://segmentfault.com/a/1190000020416577)](https://segmentfault.com/a/1190000020416577)

- 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。
- 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。
- 所有的叶子节点形成了一个有序链表，更加便于查找。

6、什么是数据库设计的三大范式？范式设计和反范式设计的优缺点？

[【MySQL】范式设计和反范式设计](https://wwxiong.com/?p=48)

设计关系型数据库需要遵守设计规范格式(Normal Format)。 

* 第一范式，是指字段具有不可拆分的原子性；

* 第二范式在满足第一范式的基础上，消除部分依赖，要求必须有主键并且非主键字段完全依赖主键（不能存在部分依赖）；判断是否依赖于主键的一部分，说明第二规则的主键是由2个或者2个以上的字段构成的。

* 第三范式在第二范式的基础上，消除传递依赖，要求非主键字段不能相互依赖。理解2NF和3NF的关键点在于，2NF-某字段依赖于主键的一部分，3NF-某字段依赖于某个非主键字段。

关于范式设计和反范式设计的选择，需要根据实际业务场景进行选择，完全的范式化和反范式化设计都是实验室里才会出现的。简单来讲，符合实际业务场景的设计便是好设计。

范式设计的优点：范式化的设计避免了大量的数据冗余，使得更新速度更快，同时也节省了存储空间，保持了数据的一致性（不必在超过两个以上的地方更改同一个值）。

范式化设计的缺点通常是需要关联许多表，这会导致在复杂查询的时候需要多次关联，降低查询效率。

在反范式的设计模式中，可以允许适当的数据冗余，用这个冗余可以缩短取数据的时间。反范式其本质上就是用空间来换取时间，把数据冗余在多个表中，当查询时就可以减少或者是避免表之间的关联。

优点：因为数据冗余，减少了表的连接甚至不连接，可以更好的利用索引筛选和排序，从而提高查询操作的性能。缺点：因为数据冗余，在更新操作或者删除操作时容易造成表中的信息不一致的问题。

| 设计       | 优点                                     | 缺点                                         |
| ---------- | ---------------------------------------- | -------------------------------------------- |
| 范式设计   | 数据没有冗余，更新操作容易，数据一致性高 | 关联表查询太多，查询性能下降                 |
| 反范式设计 | 数据大量冗余，查询性能较快               | 更新性能下降，磁盘空间消耗较大，数据一致性低 |

7、MySQL中 MyISAM 与 InnoDB 的区别，至少5点？

- InnoDB 支持事务，而 MyISAM 不支持事务。
- InnoDB 支持行级锁，而 MyISAM 支持表级锁。
- InnoDB 支持 MVCC, 而 MyISAM 不支持。
- InnoDB 支持外键，而 MyISAM 不支持。
- InnoDB 支持奔溃后的安全修复，MyISAM 崩溃后无法修复。注：InnoDB 引擎层自身的 redo log（重做日志）有 crash-safe 的能力，而 MySQL 自带的引擎是 MyISAM，Server 层 的 binlog （归档日志）只能用于归档。
- InnoDB 不支持全文索引（5.6版本之后支持），而 MyISAM 支持。
- InnoDB 不能通过直接拷贝表文件的方法拷贝表到另外一台机器， MyISAM 支持。
- InnoDB 表支持多种行格式， MyISAM 不支持。
- InnoDB 是索引组织表， MyISAM 是堆表。

8、MySQL中 VARCHAR 与 CHAR 的区别以及 VARCHAR(50) 中的50代表的涵义？int(20)中20的涵义？

VARCHA 类型用于存储可变长的字符串，无论是什么字节字符集，都存储变长数据和变长字段长度列表。

CHAR 类型是定长的，CHAR 适合存储很短的字符串，或者所有值都接近同一个长度，比如存储密码的MD5值。

 VARCHAR(50) 中的50代表最多存放50个字符。使用 VARCHAR(50) 和 VARCHAR(200) 存储 'hello' 的空间开销是一样的，但是使用长的列 VARCHAR(200) 会消耗更多的内存，因为MySQL 通常会分配固定大小的内存来保存内部值，尤其是使用内存临时表进行排序或操作时会非常糟糕，在利用磁盘临时表进行排序时也非常糟糕，所以最好的策略是只分配真正需要的空间。

int(20)是指显示字符的宽度，并不影响内部存储和计算，内部实际存储还是4个字节，只是当int字段类型设置为无符号且填充零（UNSIGNED ZEROFILL）时，当数值位数未达到设置的显示宽度时，会在数值前面补充零直到满足设定的显示宽度。

9、 InnoDB 的事务与日志的实现方式？

MySQL 有两个重要的日志模块：物理日志 redo log（重做日志）和 逻辑日志 binlog（归档日志）。

MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。

当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

redo log（重做日志）和 binlog（归档日志）的区别：

* redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
* redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
* redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

![img](系统知识.assets/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

将 redo log 的写入拆成了两个步骤：prepare 和 commit，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。

10、MySQL 数据库 CPU 飙升到500%的话怎么处理？

* ① 使用 top 命令查看是否是 mysqld 占用导致的，如果不是找出占用高的进程进行相关处理。
* ②  如果是 mysqld 占用导致的，进入 MySQL 使用 show processlist 显示用户正在运行的线程，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。
* ③ 找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。
* ④ 可以的话 kill 掉这些线程(同时观察 cpu 使用率是否下降)，进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。

11、Explain 执行计划包含的字段及说明？

[【MySQL高级】索引优化分析（二）](https://wwxiong.com/?p=92)

| 字段          | 说明               |
| ------------- | ------------------ |
| id            | 表的加载和读取顺序 |
| select_type   | 数据的访问类型     |
| table         | 所加载的表         |
| type          | 数据的查询类型     |
| possible_keys | 可能使用的索引     |
| key           | 实际使用的索引     |
| key_len       | 索引的字节数       |
| ref           | 索引引用的列       |
| rows          | 读取的行数         |
| extra         | 其他额外的信息     |

`id`：SELECT查询的序列号，包含一组数字，表示查询中执行SELECT子句或操作表的顺序。

① id相同，执行顺序由上至下。	

② id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。

③ id相同不同，同时存在。id如果相同，可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行。	

![index-optimization-03](系统知识.assets/03.jpg)

`select_type`：查询类型主要用于区别普通查询、联合查询、子查询等复杂查询，分类和说明如下所示：

| id   | 类型         | 说明                                                         |
| ---- | ------------ | ------------------------------------------------------------ |
| 1    | SIMPLE       | 查询中不包含子查询或者UNION                                  |
| 2    | PRIMARY      | 查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY    |
| 3    | SUBQUERY     | 在SELECT或WHERE列表中包含了子查询，该子查询被标记为SUBQUERY  |
| 4    | DERIVED      | 在FROM列表中包含的子查询被标记为：DERIVED（衍生）            |
| 5    | UNION        | 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在 FROM子句的子查询中，外层SELECT将被标记为：DERIVED |
| 6    | UNION RESULT | 从UNION表获取结果的SELECT被标记为：UNION RESULT              |

`table`：主要用于显示这一行的数据是关于哪张表。

`type`：显示查询使用了何种类型，总共七种类型，从最好到最差，具体类型及说明如下所示：		

| 类型   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| system | 表只有一行记录（等于MySQL自带的系统表），这是const类型的特例，平时不会出现，可以忽略。 |
| const  | 表示通过索引一次就找到了，const用于primary key或者unique索引。 |
| eq_ref | 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引。 |
| ref    | 非唯一性索引扫描，返回匹配某个单独值得所有行。               |
| range  | 只检索给定范围的行，使用一个索引来选择行，属于范围扫描索引，一般出现在where语句中使用between,<,>,in等查询。 |
| index  | Full Index Scan，只遍历索引树。                              |
| all    | Full Table Scan，将遍历全表以找到匹配的行。                  |

> 从最好到最差依次是`system>const>eq_ref>ref>range>index>all`。一般来说，要保证查询至少达到range级别，最好能达到ref。

`possible_keys`：指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。

`key`：显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。	
![index-optimization-04](系统知识.assets/04.jpg)

`key_len`：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。`key_len`显示的值为索引字段的最大可能长度，并非实际使用长度，即`key_len`是根据表定义计算而得，不是通过表内检索出的。

![image-20210320180401124](系统知识.assets/image-20210320180401124.png)

`ref`：该字段显示索引的哪一列被使用了，有可能为一个常量。简单来讲，就是指哪些列或常量被用于查找索引列上的值。	

![image-20210320180517571](系统知识.assets/image-20210320180517571.png)

`rows`：根据表统计信息及索引选用情况，大致估算出最终找到所需记录需要读取的行数。

![image-20210320180557718](系统知识.assets/image-20210320180557718.png)

`Extra`：包含不适合在其他列中显示但十分重要的额外信息，主要包含以下内容：

| 类型              | 说明               |
| ----------------- | ------------------ |
| Using filesort    | 文件排序           |
| Using temporary   | 临时表排序         |
| Using index       | 覆盖索引           |
| Using where       | 使用条件过滤       |
| Using join buffer | 使用连接缓存       |
| impossible where  | where子句值为false |

![image-20210320180800151](系统知识.assets/image-20210320180800151.png)

12、什么是索引？MySQL 索引都有哪些类型？索引的优缺点是什么？

[【MySQL高级】索引优化分析（一）](https://wwxiong.com/?p=93)

**MySQL官方对索引的定义为：索引（Index）是存储引擎用于快速找到记录的一种数据结构。本质是一种排好序的快速查找结构，目的是提高查询效率，索引的实现通常使用B树及其变种B+树。**

数据库索引是一种能够改善表操作速度的数据结构。索引可以通过一个或多个列来创建，它可以提高随机查询的速度，并在检索记录时实现高效排序。

索引的本质：一种数据结构。
索引的目的：提高查询效率。
索引解决：① where条件后面的字段拼装查询效率。②order by 后面的字段排序如何查询快。
简而言之，可以将索引理解为：排好序的快速查找结构。

MySQL 索引类型分类：

* 普通索引（INDEX 单列索引）
* 唯一索引 （UNIQUE）
* 主键索引 （PRIMARY KEY）
* 复合索引
* 全文索引 （FULLTEXT）

索引的优势：

* 索引大大减少了服务器需要扫描的数据量，加快数据的检索速度，可以提高系统的性能。
*  索引可以帮助服务器避免排序和临时表，通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。
* 索引可以将随机IO变为顺序IO，类似图书馆书目索引，提高数据检索的效率，降低数据库的IO成本。
*  创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
* 使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

索引的劣势：

* 占用空间：实际上，索引也是一张表，该表保留了主键与索引字段，并指向实体表的记录，所以索引列也是需要占用空间的。
* 降低更新表的速度：虽然索引大大提高了查询速度，但是也会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE时，都会调整因为更新所带来的键值变化后的索引信息。
* 索引优化需要花费大量的时间：索引只是提高效率的一个因素，如果表的数据量较大，就需要花时间研究去建立最优的索引，也要进行SQL优化查询。因为各种业务不同，对于所建的索引也是不同的，也需要根据实际业务去寻找最优的方式。



13、MySQL 优化的方式具体都有哪些？至少10种。

优化总结口诀：

>全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上少计算，范围之后全失效；
LIKE百分写最右，覆盖索引不写星；
不等空值还有or，索引失效要少用；
VAR引号不可丢，SQL高级也不难。

结论：
① 全值匹配最佳，所建立的索引字段与查询条件中的字段一一对应（个数和顺序一致）是最佳的。
② 如果索引为多列，要遵守最左前缀法则。查询从索引的最左前列开始并且不能跳过索引中的列。
③ 不在索引列上做任何操作（计算、函数、（自动或手动）类型转换），会导致索引失效而转向全表扫描。
④ 存储引擎不能使用索引中范围条件右边的列。
⑤ 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），避免select*。
⑥ MySQL在使用不等于（!=或者<>）的时候无法使用索引，会导致全表扫描。
⑦ is null，is not null 也无法使用索引。
⑧ like以通配符开头（%abc...）MySQL索引会失效变成全表扫描。
⑨ 字符串不加单引号索引失效。
⑩ 少用or，用它来连接时索引会失效。





# PHP 

1、PHP如何解决网站大流量和高并发的问题？

* 流量优化：例如防盗链；合理使用`CDN`加速。
* 前端优化：一是页面级优化，减少HTTP的请求（合理设置 HTTP缓存，启用浏览器缓存和静态资源过期时间缓存， CSS、 Javascript、Image 资源合并与压缩，使用异步请求）；二是代码级别的优化（Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化）；
* 服务端优化：动态语言静态化、图片服务器与`WEB`服务器分离、并发处理、消息队列处理、服务端代码优化。
* 缓存层优化：数据库缓存（`Memcached`、`Redis`、`MongoDB`）
* MySQL优化：分库分表、分区操作、读写分离、SQL调优。
* 数据库架构优化：
* 服务器优化：负载均衡（Nginx的反向代理）、浏览器静态缓存（`Nginx`静态资源缓存配置策略）。
* 架构层面优化：从架构上来说，采用前后端分离的分层架构，前端负责站点展现层（异步获取数据，响应速度提升），后端负责站点数据层（通过内网一次性返数据，性能大幅度提升）。

2、如何将1234567890转换成1,234,567,890 每3位用逗号隔开的形式？

![image-20210317175646180](系统知识.assets/image-20210317175646180.png)

```php
ltrim(strrev(chunk_split(strrev(1234567890), 3, ',')),',')
```

chunk_split — 将字符串分割成小块。

```php
chunk_split ( string $body , int $chunklen = 76 , string $end = "\r\n" ) : string
```

注：strrev函数不能解决中文字符翻转问题。

3、如何实现字符串翻转？

思路：使用正则和数组实现。

![image-20210317175949327](系统知识.assets/image-20210317175949327.png)

```java
function strUtf8() {
  return join("",array_reverse(preg_split("//u",$str)))
}
```

preg_split — 通过一个正则表达式分隔字符串。

```php
preg_split ( string $pattern , string $subject , int $limit = -1 , int $flags = 0 ) : array
```

join — 别名 implode()。

```php
implode ( string $glue , array $pieces ) : string
```

![image-20210317175806582](系统知识.assets/image-20210317175806582.png)

4、（算法）约瑟夫环问题：一群猴子排成一圈，按1,2,…,n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数， 再数到第m只，在把它踢出去…，如此不停的进行下去， 直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。

思路：每个猴子出列后，剩下的猴子又组成了另一个子问题。只是他们的编号变化了。第一个出列的猴子肯定是a[1]=m(mod)n(m/n的余数)，他除去后剩下的猴子是a[1]+1,a[1]+2,…,n,1,2,…a[1]-2,a[1]-1，对应的新编号是1,2,3…n-1。设此时某个猴子的新编号是i，他原来的编号就是(i+a[1])%n。于是，这便形成了一个递归问题。假如知道了这个子问题(n-1个猴子)的解是x，那么原问题(n个猴子)的解便是：(x+m%n)%n=(x+m)%n。问题的起始条件：如果n=1,那么结果就是1。

```php
function monkeyKing($n,$m) {  
    $r=0;  
    for($i=2; $i<=$n; $i++) {
        $r=($r+$m)%$i;  
    }
    return $r+1;  
}  
echo monkeyKing(10,3)."是猴王";
```

5、PHP的对象传值与引用传值是怎样的，有什么区别？

思路：

* 变量赋值为拷贝赋值，修改原值不受影响。
* 对象赋值另一个变量，是将对象的对象标识符拷贝一份，两个对象公用一份数据，其中一个修改，全部被修改。
* 引用传值会直接指向对象标识符，修改其中一个值，所有值均被改变。

![image-20210317102326140](系统知识.assets/image-20210317102326140.png)

![图片](系统知识.assets/640.png)

![image-20210317102404012](系统知识.assets/image-20210317102404012.png)

![图片](系统知识.assets/640-20210317102431740.png)

![image-20210317175140711](系统知识.assets/image-20210317175140711.png)

6、如何解决PHP网站访问慢的问题？

* 1、流量层面：一是检查自己服务器上的资源（图片、视频、音乐、软件等）是否做了防盗链（nginx配置方式防盗链）；二是CDN加速的使用是否合理。
* 2、前端层面：一是通过减少组件的请求次数来减少HTTP请求（使用图片地图、`css`精灵、图片密集型网站可使用图片懒加载，合并压缩`css`样式表和`js`脚本）；二是对数据文件进行压缩（`JavaScript` 代码的压缩、`CSS `代码的压缩、`HTML` 代码的压缩，`GZIP` 压缩，图片大小处理）；
* 3、服务端层面：一是使用动态语言静态化（使用`smarty`模板引擎的缓存机制生成静态`html`缓存文件），减少逻辑处理压力，降低数据库服务器查询压力；二是对服务端代码进行优化（冗余处理，业务逻辑优化），可以使用消息队列来处理某些业务。
* 4、缓存层面：使用数据库缓存，`Memcached`、`Redis`、`MongoDB`等。
* 5、MySQL数据库层面：数据库表结构、慢SQL调优、建立索引、分库分表、分区操作、读写分离。
* 6、数据库架构：
* 7、服务器层面：负载均衡（Nginx的反向代理）、浏览器静态缓存（Nginx`静态资源缓存配置策略）。
* 8、架构层面：从架构上来说，采用前后端分离的分层架构，前端负责站点展现层（异步获取数据，响应速度提升），后端负责站点数据层（通过内网一次性返数据，性能大幅度提升）。

7、leetcode 41| 缺失的第一个正数。

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。例如[1,2,3,5] 输出4。

说明：你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

思路：它需要找出第一个数组中没有的最小正整数，所以我们通过数组的索引来标识相应的正整数，比如索引0表示正整数1，以此类推，索引i表示正整数i+1，我们只需要遍历一次数组，将满足下列条件的元素交换到对应索引处，1.大于等于1，小于等于数组长度length，2.元素的值不等于当前索引值i+1，需要注意的是，每次交换之后，交换过来的值也要进行上述判断，否则继续遍历后面的元素，相当于遗漏了交换过来的这个元素。经过上面一次遍历之后，所有满足条件（1.大于等于1，小于等于数组长度length，2.元素的值不等于当前索引值i+1。）的元素全部都在对应的索引处了，即元素值等于索引值+1。再通过一次遍历，找出第一个不符合元素值等于索引值i+1的元素，返回结果i+1即为我们需要的寻找的正整数。

PHP版本：

```java

```

Java版本：

```java
int firstMissingPositive(int* nums,int length) {
    for (int i = 0; i < length; i++) {  //从数组的第一个元素开始逐一判断
        int item = nums[i];  //记录当前元素
        if (item >= 1 && item <= length && item != nums[item - 1]) {  //若1<=item<=nums.length，且item不等于i+1，就将item与它对应的i索引处的值进行交换
            swap(nums, i, item - 1);  //调用交换方法
            i--; //进行交换之后，需要对交换过来的数再次进行上述判断，即i--与循环i++抵消一次
        }
    }
    int i = 0;
    for (i = 0; i < length; i++) {  //再次遍历数组
        if (nums[i] != i + 1){ //若当前数组元素的值不等于i+1，则直接返回i+1结果
            return i + 1;
        }
    }
    return i + 1;  //当上述循环结束，程序仍然没有返回结果，则返回i+1，即nums.length+1
}

int swap(int* nums, int i, int j) {  //交换两个数
    nums[i] ^= nums[j];   //通过异或运算进行交换
    nums[j] ^= nums[i];
    nums[i] ^= nums[j];
    return 0;
}

int main (){ //此处为一个测试例子
    int nums[] = { 7, 8, 9, 11, 12 };
    printf("%d\n", firstMissingPositive(nums,5));
```

8、请写出一段PHP代码，确保多个进程同时写入同一个文件成功。（腾讯）

9、PHP 超全局变量$_SERVER。

```PHP
$_SERVER["SERVER_ADDR"] // 服务器端IP
$_SERVER["REMOTE_ADDR"] // 客户端IP
$_SERVER["SCRIPT_FILENAME"] // 当前脚本执行路径
$_SERVER["QUERY_STRING"]  // 服务器请求时？后面的参数
$_SERVER["SCRIPT_NAME"]  // 当前脚本的路径
$_SERVER["HTTP_REFERER"] // 链接到当前页面的前一页地址
```

10、isset和empty的区别？

isset — 检测变量是否已设置并且非 **`null`**。

empty — 检查一个变量是否为空。

当`var`存在，并且是一个非空非零的值时返回 **`false`** 否则返回 **`true`**.

以下的东西被认为是空的：

- `""` (空字符串)

- `0` (作为整数的0)

- `0.0` (作为浮点数的0)

- `"0"` (作为字符串的0)

- **`null`**

- **`false`**

- `array()` (一个空数组)

- `$var;` (一个声明了，但是没有值的变量)

  ![image-20210318152733187](系统知识.assets/image-20210318152733187.png)

![image-20210317231431626](系统知识.assets/image-20210317231431626.png)

11、

sort — 对数组排序，索引会由0到n-1重新编号。

asort — 对数组值进行正向排序并保持键的索引关系。

ksort — 对数组按照键名排序，适用于对索引键排序的关联数组。

arsort — 对数组值进行逆向排序并保持键的索引关系。

![image-20210317182734384](系统知识.assets/image-20210317182734384.png)

12、

count — 计算数组中的单元数目，或对象中的属性个数，通常是一个array，如果参数既不是数组，也不是实现 `Countable` 接口的对象，将返回 `1`。 有个例外：如果 `array_or_countable` 是 **`null`** 则结果是 `0`。

```php
echo count("abc"); // 1
echo count(null); // 0
echo count(false); // 1
echo count(strlen("https://wwxiong.com")); // 1
```

13、写个函数用来对二维数组排序。

![image-20210317214945094](系统知识.assets/image-20210317214945094.png)

14、写五个不同的函数，来获取一个全路径文件的扩展名，允许封装PHP中已有的函数。

![image-20210317220226550](系统知识.assets/image-20210317220226550.png)

```php
str_replace — 子字符串替换
str_replace ( mixed $search , mixed $replace , mixed $subject , int &$count = ? ) : mixed
  
strrchr — 查找指定字符在字符串中的最后一次出现。该函数返回 haystack 字符串中的一部分，这部分以 needle 的最后出现位置开始，直到 haystack 末尾。
strrchr ( string $haystack , mixed $needle ) : string  

strstr — 查找字符串的首次出现，返回 haystack 字符串从 needle 第一次出现的位置开始到 haystack 结尾的字符串。
strstr ( string $haystack , mixed $needle , bool $before_needle = false ) : string
  
strrpos — 计算指定字符串在目标字符串中最后一次出现的位置,返回字符串 haystack 中 needle 最后一次出现的数字位置。
strrpos ( string $haystack , string $needle , int $offset = 0 ) : int
  
substr — 返回字符串的子串。返回字符串 string 由 start 和 length 参数指定的子字符串。
substr ( string $string , int $start , int $length = ? ) : string
  
pathinfo — 返回文件路径的信息，返回一个关联数组包含有 path 的信息。返回关联数组还是字符串取决于 options。
pathinfo ( string $path , int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ) : mixed
  
basename — 返回路径中的文件名部分,给出一个包含有指向一个文件的全路径的字符串，本函数返回基本的文件名。
basename ( string $path , string $suffix = ? ) : string
```

```php
<?php
$foo = "0123456789a123456789b123456789c";
var_dump(strrpos($foo, '7', -5));  // 从尾部第 5 个位置开始查找 // 结果: int(17)
var_dump(strrpos($foo, '7', 20));  // 从第 20 个位置开始查找 // 结果: int(27)
var_dump(strrpos($foo, '7', 28));  // 结果: bool(false)
?>
```

```php
<?php
$path_parts = pathinfo('/www/htdocs/inc/lib.inc.php');
echo $path_parts['dirname'], "\n"; // /www/htdocs/inc
echo $path_parts['basename'], "\n"; // lib.inc.php
echo $path_parts['extension'], "\n"; // php
echo $path_parts['filename'], "\n"; // lib.inc
?>
```

```php
<?php
$email  = 'name@example.com';
$domain = strstr($email, '@');
echo $domain; // 打印 @example.com

$user = strstr($email, '@', true); // 从 PHP 5.3.0 起
echo $user; // 打印 name
?>
```

15、

```php
strcasecmp — 二进制安全比较字符串（不区分大小写）,如果 str1 小于 str2 返回 < 0； 如果 str1 大于 str2 返回 > 0；如果两者相等，返回 0。
strcasecmp ( string $str1 , string $str2 ) : int
  
strcmp — 二进制安全字符串比较，注意该比较区分大小写。
strcmp ( string $str1 , string $str2 ) : int

in_array — 检查数组中是否存在某个值，在（haystack）中搜索（ needle），如果没有设置 strict 则使用宽松的比较。
in_array ( mixed $needle , array $haystack , bool $strict = false ) : bool
```



![image-20210317230413963](系统知识.assets/image-20210317230413963.png)

16、

![image-20210317231115245](系统知识.assets/image-20210317231115245.png)

17、

```php
array_map — Applies the callback to the elements of the given arrays
```

```php
<?php
function cube($n){
    return ($n * $n * $n);
}

$a = [1, 2, 3, 4, 5];
$b = array_map('cube', $a);
print_r($b);
?>
  
```

![image-20210317231803871](系统知识.assets/image-20210317231803871.png)



18、数组处理。

![image-20210318141826529](系统知识.assets/image-20210318141826529.png)



```java
array_slice — 从数组中取出一段，array_slice() 返回根据 offset 和 length 参数所指定的 array 数组中的一段序列。
array_slice ( array $array , int $offset , int $length = null , bool $preserve_keys = false ) : array
```

19、max — Find highest value。

```php
max ( mixed $value , mixed ...$values ) : mixed
```

![image-20210318144644557](系统知识.assets/image-20210318144644557.png)

20、PHP的比较运算符。

![PHP比较运算符](系统知识.assets/bVvdtw.png)

```php
0 == false: bool(true)
0 === false: bool(false)

0 == null: bool(true)
0 === null: bool(false)

false == null: bool(true)
false === null: bool(false)

"0" == false: bool(true)
"0" === false: bool(false)

"0" == null: bool(false)
"0" === null: bool(false)

"" == false: bool(true)
"" === false: bool(false)

"" == null: bool(true)
"" == null: bool(false)
```



21、unset — 释放给定的变量。

如果在函数中 unset() 一个通过引用传递的变量，则只是局部变量被销毁，而在调用环境中的变量将保持调用 unset() 之前一样的值。

```php
<?php
function foo(&$bar) {
    unset($bar);
    $bar = "blah";
}

$bar = 'something';
echo "$bar\n"; // something

foo($bar);
echo "$bar\n"; // something
?>
```

![image-20210318155847483](系统知识.assets/image-20210318155847483.png)

![image-20210318171916912](系统知识.assets/image-20210318171916912.png)

22、局部变量和全局变量。

![image-20210318161118275](系统知识.assets/image-20210318161118275.png)

23、常用的数组函数。

```php
array_unshift — 在数组开头插入一个或多个单元，
array_unshift ( array &$array , mixed ...$values ) : int
array_unshift() 将传入的单元插入到 array 数组的开头。注意单元是作为整体被插入的，因此传入单元将保持同样的顺序。所有的数值键名将修改为从零开始重新计数，所有的文字键名保持不变。
  
array_rand — 从数组中随机取出一个或多个随机键,从数组中取出一个或多个随机的单元，并返回随机条目对应的键（一个或多个）。 
array_rand ( array $array , int $num = 1 ) : int|string|array
  
array_merge — 合并一个或多个数组。
array_merge ( array $... = ? ) : array

  
  
  
```

```php
in_array — 检查数组中是否存在某个值,在（haystack）中搜索（ needle），如果没有设置 strict 则使用宽松的比较。
in_array ( mixed $needle , array $haystack , bool $strict = false ) : bool
```

```php
<?php
$a = array('1.10', 12.4, 1.13);

if (in_array('12.4', $a, true)) {
    echo "'12.4' found with strict check\n"; // 不输出
}

if (in_array(1.13, $a, true)) {
    echo "1.13 found with strict check\n"; // 输出
}
```

![image-20210319100036632](系统知识.assets/image-20210319100036632.png)

24、常用的字符串函数。

```php
strstr — 查找字符串的首次出现，返回 haystack 字符串从 needle 第一次出现的位置开始到 haystack 结尾的字符串。before_needle 若为 true，strstr() 将返回 needle 在 haystack 中的位置之前的部分。
strstr ( string $haystack , mixed $needle , bool $before_needle = false ) : string  
```

```php
<?php
$email  = 'name@example.com';
$domain = strstr($email, '@');
echo $domain; // 打印 @example.com

$user = strstr($email, '@', true); // 从 PHP 5.3.0 起
echo $user; // 打印 name
?>
```

![image-20210318174028941](系统知识.assets/image-20210318174028941.png)

25、PHP全局环境变量。

```php
$GLOBALS — 引用全局作用域中可用的全部变量
$_SERVER — 服务器和执行环境信息
$_GET — HTTP GET 变量
$_POST — HTTP POST 变量
$_FILES — HTTP 文件上传变量
$_REQUEST — HTTP Request 变量
$_SESSION — Session 变量
$_ENV — 环境变量
$_COOKIE — HTTP Cookies
```









# Redis 

* `Redis Setnx`（`SET if Not eXists`） 命令在指定的 key 不存在时，为 key 设置指定的值。如果不存在设置成功返回1，如果存在不覆盖，设置失败返回0。



#   Git 

## 命令大全

```java
git fetch // 从远程获取最新版本到本地，不会merge（合并）
git pull // 从远程获取最新版本并 merge（合并）到本地，等同于 git fetch + git merge
git checkout -- <file>... // 撤销本地文件的所有修改 （清理工作区文件）discard changes in working directory
git reset HEAD <file>  // 撤销上一次向暂存区添加的某个指定文件，不影响工作区中的该文件 unstage(暂存区到工作区)
git reset --hard // 同时撤销暂存区和工作区的修改，恢复到上一次提交的状态 等同于 git reset --hard HEAD
git reset  // 撤销上一次向暂存区添加的所有文件
git clean -f // 批量删除branch中新加的文件(untracked files)
  
```

## 错误解决

问题1:

> ➜  mall git:(master) git pull  
> error: You have not concluded your merge (MERGE_HEAD exists).
> hint: Please, commit your changes before merging.
> fatal: Exiting because of unfinished merge.

解决：你还没有完成合并。有可能是之前 `pull `过代码，自动合并失败，有两种解决方法。

解决方法一：如果需要保留本地的更改，中止合并->重新合并->重新拉取。

```java
$:git merge --abort
$:git reset --merge
$:git pull
```

解决方法二：舍弃本地代码，远程版本覆盖本地版本（慎用）。

```java
$:git fetch --all
$:git reset --hard origin/master
$:git fetch
```

问题2：

> [root@hexin-c11-168 h5-web]# git pull
> remote: Enumerating objects: 131, done.
> remote: Counting objects: 100% (131/131), done.
> remote: Compressing objects: 100% (95/95), done.
> fatal: Unable to create temporary file '/export/data/tomcat/mall/h5-web/.git/objects/pack/tmp_pack_XXXXXX': No space left on device
> fatal: index-pack failed

解决：`No space left on device`，磁盘空间满了，清除无用的大文件数据。

问题3：

> ➜  sudo git clone git@github.com:xxx/TechDoc.git
> Password:
> Cloning into 'TechDoc'...
> git@github.com: Permission denied (publickey).
> fatal: Could not read from remote repository.
>
> Please make sure you have the correct access rights
> and the repository exists.

解决：

> ➜  ssh-agent -s
> SSH_AUTH_SOCK=/var/folders/t0/gpltt0xd32gbs9wr5bgd8w0000gn/T//ssh-Sp0knrn8EXwq/agent.4949; export SSH_AUTH_SOCK;
> SSH_AGENT_PID=4950; export SSH_AGENT_PID;
> echo Agent pid 4950;
> ➜  ssh-add ~/.ssh/id_rsa
> Identity added: /Users/wangxiong/.ssh/id_rsa ()



#  Docker 

## 常用命令

```dockerfile
# 列出本机所有容器，包括终止运行的容器
docker ps -a
# 进入容器终端并且的保留为容器终端的输入形式
docker exec -it cda2919d4813 /bin/bash
# 列出镜像列表
docker images
# 获取新的镜像
docker pull ubuntu:13.10
# 删除镜像文件
docker image rm [imageName]
# 使用镜像运行容器
docker run -t -i ubuntu:13.10 /bin/bash
# 删除容器
docker rm 76f1912f92ac
```



# LINUX 

* `netstat -tunlp`  用于显示 `tcp`，`udp` 的端口和进程等相关情况。
* `lsof（list open files） -i`  用于列出当前系统打开文件的工具。
* `ps（Process Status） -aux | grep xxx` 查看系统的进程状态。
* `cat /etc/redhat-release && cat /etc/lsb-release` 查看系统及其版本信息。
* `service iptables status` 查看`Centos 6.x`版本 `iptables`防火墙状态。
* `firewall-cmd --state` 查看`Centos 7.x`版本 `firewall`防火墙状态。
* `kill -signal pid`：`kill -9` 发送`SIGKILL`信号给进程，告诉进程，你被终结了，请立刻退出。



## SCP

```
scp /Users/hexindai/workspace/hexin-ashes/hexin-search-api/target/hexin-search-api.war root@172.20.10.xx:/export/data/tomcatRoot/javasearch.hexindai.com/
```



## top

作用：显示当前系统正在执行的进程的相关信息，包括进程`ID`、内存占用率、`CPU`占用率等。
英文：The top program provides a dynamic real-time view of a running system.
参数：

| 参数       | 说明             |
| ---------- | ---------------- |
| -b         | 批处理           |
| -c         | 显示完整的治命令 |
| -I         | 忽略失效过程     |
| -s         | 保密模式         |
| -S         | 累积模式         |
| -i<时间>   | 设置间隔时间     |
| -u<用户名> | 指定用户名       |
| -p<进程号> | 指定进程         |
| -n<次数>   | 循环显示的次数   |

实例1：显示当前进程信息。

```linux
[root@iZrj9hb9k9jtcpp85t8ryeZ ~]# top
top - 16:55:44 up 70 days, 22:39, 2 users, load average: 0.29, 0.10, 0.07
Tasks: 83 total, 1 running, 82 sleeping, 0 stopped, 0 zombie
%Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
KiB Mem : 1016164 total, 142848 free, 216332 used, 656984 buff/cache
KiB Swap: 1048572 total, 881460 free, 167112 used. 594816 avail Mem
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
4343 root 20 0 424948 14220 3016 S 0.3 1.4 72:41.60 docker-containe
10620 root 20 0 132656 11972 9068 S 0.3 1.2 90:20.35 AliYunDun
24045 root 20 0 154600 5524 4212 S 0.3 0.5 0:00.02 sshd
1 root 20 0 199092 2804 1480 S 0.0 0.3 13:01.77 systemd
```

第一行：系统运行信息，同`uptime`命令的执行结果，详细说明如下：

| 参数                           | 说明                                               |
| ------------------------------ | -------------------------------------------------- |
| 16:55:44                       | 当前系统时间                                       |
| up 70 days, 22:39              | 当前系统已经运行的时间为70天22小时39分钟（未重启） |
| 2 users                        | 当前有两个用户登录系统                             |
| load average: 0.29, 0.10, 0.07 | 1分钟、5分钟、15分钟的负载情况为0.29,0.10,0.07     |

> 注：`load average`数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑`CPU`的数量，结果高于5的时候就表明系统在超负荷运转了。

第二行：`Tasks` — 任务（进程），具体信息说明如下：

| 参数        | 说明               |
| ----------- | ------------------ |
| 83 total    | 系统总进程数量83个 |
| 1 running   | 处于运行状态1个    |
| 82 sleeping | 处于睡眠状态82个   |
| 0 stopped   | 处于停止状态0个    |
| 0 zombie    | 处于僵尸状态0个    |

第三行：`cpu`状态信息，具体属性说明如下：

| 参数    | 说明                                     |
| ------- | ---------------------------------------- |
| 0.3 us  | 用户空间占比，0.3%                       |
| 0.3 sy  | 内核空间占比，0.3%                       |
| 0.0 ni  | 改变过优先级的进程CPU占比，0.0%          |
| 99.3 id | 空闲CPU占比，99.3%                       |
| 0.0 wa  | IO等待CPU占比，0.00%                     |
| 0.0 hi  | 硬中断（Hardware IRQ）占比，0.00%        |
| 0.0 si  | 软中断（Software Interrupts）占比，0.00% |
| 0.0 st  | 占比，0.00%                              |

第四行：内存状态统计，具体信息如下：

| 参数              | 说明                      |
| ----------------- | ------------------------- |
| 1016164 total     | 物理总内存量（1G）        |
| 142848 free       | 空闲内存量（0.13G）       |
| 216332 used       | 使用中的内存总量（0.25G） |
| 656984 buff/cache | 缓存的内存量（0.62G）     |

第五行：`swap`交换分区信息，具体信息说明如下：

| 参数          | 说明                      |
| ------------- | ------------------------- |
| 1048572 total | 交换区总量（1G）          |
| 881460 free   | 空闲的交换区总量（0.80G） |
| 167112 used   | 使用的交换区总量（0.20G） |

第六行：空行

第七行：各进程（任务）的状态监控，项目列信息说明如下：

| 列名称   | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| PID      | 进程id                                                       |
| USER     | 进程所有者                                                   |
| PR       | 进程优先级                                                   |
| NI(NICE) | 负值表示高优先级，正值表示低优先级。                         |
| VIRT     | 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES                |
| RES      | 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA    |
| SHR      | 共享内存大小，单位kb。                                       |
| S        | 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 |
| %CPU     | 上次更新到现在的CPU时间占用百分比。                          |
| %MEM     | 进程使用的物理内存百分比。                                   |
| TIME     | 进程使用的CPU时间总计，单位1/100秒。                         |
| COMMAND  | 进程名称（命令名/命令行）。                                  |

## netstat

作用：用来打印`Linux`中网络系统的状态信息，获取整个`Linux`系统的网络情况。

英文：`network statistics`, Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships.

选项：

| 选项 | 说明       | 作用                                       |
| ---- | ---------- | ------------------------------------------ |
| -a   | --all      | 显示所有连线中的Socket。                   |
| -t   | --tcp      | 显示TCP传输协议的连线状况。                |
| -u   | --udp      | 显示UDP传输协议的连线状况。                |
| -n   | --numeric  | 直接使用ip地址，而不通过域名服务器。       |
| -p   | --programs | 显示正在使用Socket的程序识别码和程序名称。 |
| -l   | -listening | 显示监控中的服务器的Socket。               |
| -e   | --extend   | 显示网络其他相关信息。                     |

实例1：禁用反向域名解析,只列出 TCP 或 UDP 协议的连接。

```linux
[root@wx /]# netstat -antu
Proto Recv-Q Send-Q Local Address Foreign Address State
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN
udp 0 0 0.0.0.0:68 0.0.0.0:*
```

实例2：只列出监听中的`nginx`连接，要求获取进程名(-p)、进程号(-p)以及用户 ID(-e)。

```linux
[root@wx /]# netstat -lnept | grep nginx
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 0 30270 13332/nginx: master
```

实例3：查看端口占用情况（redis-6379，mysql-3306）

```linux
[root@wx /]# netstat -tunpl | grep 3306
tcp6 0 0 :::3306 :::* LISTEN 22311/mysqld
```

实例4：

```powershell
[root@wangxiong domains]# netstat -tunlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      31377/php-fpm: mast 
```

实例5：

```shell
[root@hexin-c11-168 domains]# netstat -tunlp | grep java
tcp6       0      0 :::8085                 :::*                    LISTEN      22301/java          
tcp6       0      0 :::8086                 :::*                    LISTEN      22289/java          
tcp6       0      0 :::8992                 :::*                    LISTEN      4433/java
```

## lsof

`lsof(list open files)`是一个列出当前系统打开文件的工具。

`lsof `查看端口占用语法格式：

```shell
lsof -i:端口号
```

使用`-i:port`来显示与指定端口相关的网络信息：
```powershell
[root@wangxiong ~]# lsof -i:8088
COMMAND   PID  USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME
nginx   30357 admin   25u  IPv4 198359762      0t0  TCP *:radan-http (LISTEN)
nginx   30358 admin   25u  IPv4 198359762      0t0  TCP *:radan-http (LISTEN)
```

通过在`-i`后提供对应的协议来仅仅显示`TCP`或者`UDP`连接信息：

```php
[root@wangxiong ~]# lsof -iTCP
COMMAND     PID  USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME
systemd       1  root   49u  IPv4     22610      0t0  TCP *:sunrpc (LISTEN)
systemd       1  root   54u  IPv6     22612      0t0  TCP *:sunrpc (LISTEN)
```

## ps

作用：显示当前系统中进程的快照。也就是说，该命令能捕获系统在某一事件的进程状态。
英文：`processes snapshot`,report a snapshot of the current processes.

选项：

| 选项 | 说明                   | 作用                         |
| ---- | ---------------------- | ---------------------------- |
| a    | all                    | 显示所有进程                 |
| -a   | -all                   | 显示同一终端下的所有进程     |
| -A   | Identical to -e.       | 显示所有进程                 |
| -e   | Identical to -A.       | Select all processes.        |
| f    | Do full-format listing | 显示程序之间的关系           |
| u    | userlist               | 指定用户的所有进程           |
| -au  |                        | 显示本用户的详细信息         |
| -aux |                        | 显示所有包含其他使用者的行程 |

实例1：使用`cpu`和内存升序排序来过滤进程，并通过管道显示前10个结果。

```linux
[root@wx /]# ps -aux --sort -pcpu,-pmem | head -n 10
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 10620 0.2 1.1 132656 11968 ? Ssl 9月12 89:52 /usr/local/aegis/aegis_client/aegis_10_51/AliYunDun
root 25 0.1 0.0 0 0 ? S 7月24 147:03 [kswapd0]
```

实例2：使用`PS`实时监控进程状态（动态显示，每秒刷新一次）

```linux
[root@wx /]# watch -n 1 'ps -aux --sort -pcpu,-pmem | head -n 10'
```

实例3：查找特定进程的信息

```linux
[root@wx /]# ps -ef | grep nginx
[root@wx /]# ps -aux|grep nginx
```

## tar

先来弄清两个基础概念：打包和压缩。
打包：是指将一大堆文件或目录变成一个总的文件。
压缩：则是将一个大的文件通过一些压缩算法变成一个小文件。

`tar`命令可以为`linux`的文件和目录创建档案。利用`tar`，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。

语法：

```
tar(选项)(参数)
```

选项：

| 选项 | 说明                   | 作用                       |
| ---- | ---------------------- | -------------------------- |
| -x   | --extract(提取)或--get | 从备份文件中还原文件。     |
| -z   | --gzip或--ungzip       | 通过gzip指令处理备份文件。 |
| -v   | --verbose(详细)        | 显示指令执行过程。         |
| -f   | --file                 | 指定备份文件。             |
| -c   | --create               | 建立新的备份文件。         |
| -t   | --list                 | 列出备份文件的内容。       |

应用1：以 `gzip` 压缩打包`file`文件夹并命名为`file.tar.gz`（显示打包详细过程）。

```linux
[root@wx wdata] tar -czvf file.tar.gz file
```

应用2：解压`file.tar.gz`包并命名为`file`（显示解压详细过程）

```linux
[root@wx wdata] tar -xzvf file.tar.gz file
```

应用3：显示`file.tar.gz`包中的内容。

```linux
[root@wx wdata] tar -tzvf file.tar.gz
```



## find

实例1：查找超过10MB的所有`.mp3`文件，并使用一个命令删除它们 。

```linux
[root@wx /]# find / -type f -name "*.mp3" -size +10M -exec rm {} \;
```



实例2：查找当前目录下所有目录名为`CVS`的子目录的命令。

```linux
[root@wx /]# find ./CVS -maxdepth 1 -type d -print
```



## df

作用：用于显示磁盘空间使用情况。
英文：`disk free`,report file system disk space usage.

| 选项 | 说明             | 作用                 |
| ---- | ---------------- | -------------------- |
| -T   | --print-type     | 显示文件系统的形式。 |
| -h   | --human-readable | 使用人类可读的格式。 |

```linux
[root@wx server]# df -Th
文件系统 类型 容量 已用 可用 已用% 挂载点
/dev/vda1 ext4 40G 7.4G 30G 20% /
devtmpfs devtmpfs 487M 0 487M 0% /dev
tmpfs tmpfs 497M 0 497M 0% /dev/shm
tmpfs tmpfs 497M 644K 496M 1% /run
```

## du

作用：用于显示目录或文件的大小。
英文：`disk usage`,estimate file space usage.

| 选项 | 说明             | 作用                                |
| ---- | ---------------- | ----------------------------------- |
| -s   | --summarize      | 仅显示总计。                        |
| -h   | --human-readable | 以K，M，G为单位，提高信息的可读性。 |

```linux
[root@wx server]# du -sh ./*
108K    ./package.xml
165M    ./php7
8.5M    ./redis-4.0.11
1.7M    ./redis-4.0.11.tar.gz
8.9M    ./xdebug-2.6.1
```

## 系统版本

命令1：

```shell
[root@wangxiong ~]# cat /etc/redhat-release && cat /etc/lsb-release
CentOS Linux release 7.6.1810 (Core) 
cat: /etc/lsb-release: No such file or directory
```

> 如果能确定系统是Redhat或Centos：使用cat  /etc/redhat-release 这个文件。
>
> 如果能确定系统是Ubuntu : 使用/etc/lsb-release 这个文件。

命令2：

```powershell
[root@wangxiong ~]# yum -help && apt-get -help
Usage: yum [options] COMMAND
-bash: apt-get: command not found
```

> 出现 yum 的就是 Centos ；出现 apt-get 的就是 Ubuntu。
>

命令3：

```powershell
[root@wangxiong ~]# cat /etc/issue
\S
Kernel \r on an \m
```

> 出现 Ubuntu 字样为 Ubuntu，没有则是 Centos。
>

## 防火墙

`Centos 6.x`版本 `iptables`：

```powershell
// 查看防火墙，iptables: Firewall is not running. 说明防火墙没有开启。
[root@centos6 ~]# service iptables status  
// 开启防火墙
[root@centos6 ~]# service iptables start
// 关闭防火墙
[root@centos6 ~]# service iptables stop
```

`Centos 7.x`版本 `firewalld`：

> `CentOS7` 默认使用`firewalld`防火墙。如果想换回`iptables`防火墙，可关闭`firewalld`并安装`iptables`。

```powershell
// 查看firewall（关闭后显示not running，开启后显示running）
[root@centos7 ~]# firewall-cmd --state 
// 关闭firewall
[root@centos7 ~]# systemctl stop firewalld.service
// 开启firewalld
[root@centos7 ~]# systemctl start firewalld.service
// 禁止firewall开机启动
[root@centos7 ~]# systemctl disable firewalld.service
// 设置firewall开机启动
[root@wangxiong ~]# systemctl enable iptables.service
// 重启firewall使配置生效
[root@wangxiong ~]# systemctl restart iptables.service
```



# SHELL

* `nohup`：不挂断运行。

* `&`：在后台运行。

* `#!/bin/bash`：定义使用`bash`解释器来解释脚本。

* `#!/bin/sh`：定义使用`sh`解释器来解释脚本。

* `grep -v grep`：去除包含`grep`的进程行。

  ```shell
  [root@wangxiong mall] # grep --help
  -v, --invert-match        select non-matching lines
  [root@wangxiong mall]# ps aux | grep 8080
  root      1363  0.1  0.8 958080 145456 ?       Ssl  Sep15  74:33 minio server /data
  root     17798  0.0  0.0 110272   904 pts/0    S+   15:20   0:00 grep --color=auto 8080
  [root@wangxiong mall]# ps aux | grep  8080 | grep -v grep
  root      1363  0.1  0.8 958080 145456 ?       Ssl  Sep15  74:33 minio server /data
  ```

* `[ -n "$a" ] `： 判断参数是否赋值。

```shell
# 判断a这个参数是否赋值，因为没赋值，所以返回flase
if [ -n "$a" ] 
then
    echo true
else
    echo false
fi
```



```shell
#!/bin/bash

# Profile
profile=dev

# jar 包路径
jarPath=/export/data/tomcatRoot/mall

cd ${jarPath}

# PORTAL
portalPackage=portal-1.0-SNAPSHOT

portalPid=`ps aux | grep ${portalPackage} | grep -v grep | awk '{print $2}'`
if [ -n "$portalPid" ]; then
        kill -9 $portalPid;
fi

nohup java -jar -Dspring.profiles.active=${profile} ${jarPath}/mall-${portalPackage}.jar >> portal.out 2>&1 &
```



# NGINX

## 反向代理

配置 `nginx` 反向代理：

```nginx
server {
     listen          8088;
     location / {
         root  /export/admin/dist/;
         index index.html;
     }
 }

server{
    listen 80;
    server_name wwxiong.com;

    charset utf-8;

    location / {
        proxy_pass         http://127.0.0.1:8088;
        proxy_set_header   Host             $host;
        proxy_set_header   X-Real-IP        $remote_addr;
        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        proxy_http_version 1.1;
        proxy_set_header Connection "upgrade";
                proxy_set_header Upgrade $http_upgrade;
                proxy_read_timeout 120s;
    }

    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }
}
```

# 网络协议

## HTTP 请求方法

浏览器的第一步工作是对 `URL` 进行解析，当解析完成以后接下来就是浏览器需要告诉服务器进行怎样的操作，我们称之为方法。最常用的方法是`GET `和`POST`方法，除此之外还有很多其他的方法，比如`PUT `和 `DELETE` 等方法，我们需要认真思考一下它们的含义，以便理解 `HTTP` 协议具备的所有功能，以下为`HTTP`的主要方法及其含义：

| 方法    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 获取 `URI `指定的信息。如果 `URI` 指定的是文件，则返回文件的内容；如果 `URI `指定的是 `CGI `程序，则返回该程序的输出数据。 |
| POST    | 从客户端向服务器发送数据。一般用于发送表单中填写的数据等情况下。 |
| HEAD    | 和 `GET` 基本相同。不过它只返回 `HTTP` 的消息头 (`message` `header`)，而并不返回数据的内容。用于获取文件最后更新时间等属性信息。 |
| OPTIONS | 用于通知或查询通信选项。                                     |
| PUT     | 替换 `URI` 指定的服务器上的文件。如果 `URI` 指定的文件不存在，则创建该文件。 |
| DELETE  | 删除 `URI` 指定的服务器上的文件。                            |
| TRACE   | 将服务器收到的请求行和头部(`header`)直接返回给客户端。用于在使用代理的环境中检查改写请求 的情况。 |
| CONNECT | 使用代理传输加密消息时使用的方法。                           |

> 问：GET和POST 的区别？

这个问题看似很简单，其实网上的很多答案都是不正确的。从标准上来看，`GET` 和 `POST `的区别如下：

* `GET` 用于获取资源，是无副作用的，是幂等的，且可缓存。

* `POST` 用于处理资源，有副作用，非幂等，不可缓存。

可以用以下图来表示：

| 幂等性 | 改变服务器上资源的状态 | 不改变服务器上资源的状态 |
| ------ | ---------------------- | ------------------------ |
| 幂等   | PUT                    | GET                      |
| 非幂等 | POST                   | 无                       |

首先我们需要知道`RFC7231`里定义了`HTTP`方法的几个性质：


* ① `Safe` - 安全性。这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。 此`RFC`定义，`GET`、`HEAD`、 `OPTIONS` 和 `TRACE` 这几个方法是安全的。但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，比如说可以使用`GET`修改用户信息的情况。引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。`User Agent`（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。

* ② `Idempotent`- 幂等性。幂等性的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照`RFC`规范，`PUT`、`DELETE`都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退或者刷新时遇到`POST`会给用户提示的原因：`POST`语义不是幂等的，重复请求可能会带来意想不到的后果。

* ③ `Cacheable` - 可缓存性。顾名思义就是一个方法是否可以被缓存，此`RFC`里`GET`，`HEAD`和某些情况下的`POST`都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持`GET`和`HEAD`。

关于`GET`和`POST` 这两种方法的语义，`RFC7231`里原文定义如下：

> The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.

> The POST method requests that the target resource process the representation enclosed in the request according to the resource’s own specific semantics.

以下为错误的认识：

① `GET`方法对数据长度有限制而`POST`方法没有限制？事实上，`HTTP`协议明确地指出了，`HTTP`头和`Body`都没有长度的要求，对 `URL` 限制的大多是浏览器和服务器的原因。服务器是因为处理长 `URL` 要消耗比较多的资源，为了性能和安全（防止恶意构造长 `URL` 来攻击）考虑，会给 `URL` 长度加限制，如果有人恶意地构造几个几M大小的`URL`，并不停地访问你的服务器，服务器性能就会下降。

② `POST` 方法比` GET `方法安全？有人说`POST` 比`GET`安全，因为数据在地址栏上不可见。然而，从传输的角度来说，他们都是不安全的，因为 `HTTP` 在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 `HTTPS`进行传输。

## HTTP 状态码

`HTTP` 响应消息中状态码的第一位数字表示状态类型，第二、三位数字表示具体的情况。下表列举了第一位数字的含义，`HTTP`状态码分类:

| 分类 | 分类描述                                                     |
| ---- | ------------------------------------------------------------ |
| 1xx  | 告知请求的处理进度和情况，服务器收到请求，需要请求者继续执行操作 |
| 2xx  | 成功，操作被成功接收并处理                                   |
| 3xx  | 表示需要进一步操作                                           |
| 4xx  | 客户端错误，请求包含语法错误或无法完成请求                   |
| 5xx  | 服务器错误，服务器在处理请求的过程中发生了错误               |

常用的`HTTP`状态码：

| 状态码 | 英文                  | 说明                                 |
| ------ | --------------------- | ------------------------------------ |
| 100    | Continue              | 继续。客户端应继续其请求             |
| 200    | OK                    | 请求成功                             |
| 300    | Multiple Choices      | 请求的资源可包括多个位置             |
| 301    | Moved Permanently     | 资源（网页等）被永久转移到其它URL    |
| 302    | Temporarily Moved     | 临时重定向，暂时性转移               |
| 304    | Not Modified          | 客户端已经执行了GET，但文件未变化。  |
| 400    | Bad Request           | 客户端请求的语法错误，服务器无法理解 |
| 403    | Forbidden             | 服务器已经理解请求，但是拒绝执行它   |
| 404    | Not Found             | 请求的资源（网页等）不存在           |
| 500    | Internal Server Error | 内部服务器错误                       |
| 502    | Bad Gateway           | 服务器接收到上游服务器的无效响应     |
| 504    | Gateway Time-out      | 网关超时，上游服务器超时             |

## HTTP 请求头

| 协议头              | 说明                                                         | 示例                                                    | 状态       |
| :------------------ | :----------------------------------------------------------- | :------------------------------------------------------ | :--------- |
| Accept              | 可接受的响应内容类型（`Content-Types`）。                    | `Accept: text/plain`                                    | 固定       |
| Accept-Charset      | 可接受的字符集                                               | `Accept-Charset: utf-8`                                 | 固定       |
| Accept-Encoding     | 可接受的响应内容的编码方式。                                 | `Accept-Encoding: gzip, deflate`                        | 固定       |
| Accept-Language     | 可接受的响应内容语言列表。                                   | `Accept-Language: en-US`                                | 固定       |
| Accept-Datetime     | 可接受的按照时间来表示的响应内容版本                         | Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT          | 临时       |
| Authorization       | 用于表示HTTP协议中需要认证资源的认证信息                     | Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==       | 固定       |
| Cache-Control       | 用来指定当前的请求/回复中的，是否使用缓存机制。              | `Cache-Control: no-cache`                               | 固定       |
| Connection          | 客户端（浏览器）想要优先使用的连接类型                       | `Connection: keep-alive``Connection: Upgrade`           | 固定       |
| Cookie              | 由之前服务器通过`Set-Cookie`（见下文）设置的一个HTTP协议Cookie | `Cookie: $Version=1; Skin=new;`                         | 固定：标准 |
| Content-Length      | 以8进制表示的请求体的长度                                    | `Content-Length: 348`                                   | 固定       |
| Content-MD5         | 请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果 | Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==                   | 废弃       |
| Content-Type        | 请求体的MIME类型 （用于POST和PUT请求中）                     | Content-Type: application/x-www-form-urlencoded         | 固定       |
| Date                | 发送该消息的日期和时间（以[RFC 7231](http://tools.ietf.org/html/rfc7231#section-7.1.1.1)中定义的"HTTP日期"格式来发送） | Date: Dec, 26 Dec 2015 17:30:00 GMT                     | 固定       |
| Expect              | 表示客户端要求服务器做出特定的行为                           | `Expect: 100-continue`                                  | 固定       |
| From                | 发起此请求的用户的邮件地址                                   | `From: user@itbilu.com`                                 | 固定       |
| Host                | 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。 | `Host: www.itbilu.com:80``Host: www.itbilu.com`         | 固定       |
| If-Match            | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 | If-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"            | 固定       |
| If-Modified-Since   | 允许在对应的资源未被修改的情况下返回304未修改                | If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT        | 固定       |
| If-None-Match       | 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 | If-None-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"       | 固定       |
| If-Range            | 如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体 | If-Range: "9jd00cdj34pss9ejqiw39d82f20d0ikd"            | 固定       |
| If-Unmodified-Since | 仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。   | If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT      | 固定       |
| Max-Forwards        | 限制该消息可被代理及网关转发的次数。                         | `Max-Forwards: 10`                                      | 固定       |
| Origin              | 发起一个针对[跨域资源共享](http://itbilu.com/javascript/js/VkiXuUcC.html)的请求（该请求要求服务器在响应中加入一个`Access-Control-Allow-Origin`的消息头，表示访问控制所允许的来源）。 | `Origin: http://www.itbilu.com`                         | 固定: 标准 |
| Pragma              | 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。 | `Pragma: no-cache`                                      | 固定       |
| Proxy-Authorization | 用于向代理进行认证的认证信息。                               | Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2== | 固定       |
| Range               | 表示请求某个实体的一部分，字节偏移以0开始。                  | `Range: bytes=500-999`                                  | 固定       |
| Referer             | 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。`Referer`其实是`Referrer`这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用`Referer`了。 | Referer: http://itbilu.com/nodejs                       | 固定       |
| TE                  | 浏览器预期接受的传输时的编码方式：可使用回应协议头`Transfer-Encoding`中的值（还可以使用"trailers"表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。 | `TE: trailers,deflate`                                  | 固定       |
| User-Agent          | 浏览器的身份标识字符串                                       | `User-Agent: Mozilla/……`                                | 固定       |
| Upgrade             | 要求服务器升级到一个高版本协议。                             | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11          | 固定       |
| Via                 | 告诉服务器，这个请求是由哪些代理发出的。                     | Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)          | 固定       |
| Warning             | 一个一般性的警告，表示在实体内容体中可能存在错误。           | Warning: 199 Miscellaneous warning                      | 固定       |

## HTTP 响应头

| 响应头                      | 说明                                                         | 示例                                                         | 状态       |
| :-------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--------- |
| Access-Control-Allow-Origin | 指定哪些网站可以`跨域源资源共享`                             | `Access-Control-Allow-Origin: *`                             | 临时       |
| Accept-Patch                | 指定服务器所支持的文档补丁格式                               | Accept-Patch: text/example;charset=utf-8                     | 固定       |
| Accept-Ranges               | 服务器所支持的内容范围                                       | `Accept-Ranges: bytes`                                       | 固定       |
| Age                         | 响应对象在代理缓存中存在的时间，以秒为单位                   | `Age: 12`                                                    | 固定       |
| Allow                       | 对于特定资源的有效动作;                                      | `Allow: GET, HEAD`                                           | 固定       |
| Cache-Control               | 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒 | `Cache-Control: max-age=3600`                                | 固定       |
| Connection                  | 针对该连接所预期的选项                                       | `Connection: close`                                          | 固定       |
| Content-Disposition         | 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。 | Content-Disposition: attachment; filename="fname.ext"        | 固定       |
| Content-Encoding            | 响应资源所使用的编码类型。                                   | `Content-Encoding: gzip`                                     | 固定       |
| Content-Language            | 响就内容所使用的语言                                         | `Content-Language: zh-cn`                                    | 固定       |
| Content-Length              | 响应消息体的长度，用8进制字节表示                            | `Content-Length: 348`                                        | 固定       |
| Content-Location            | 所返回的数据的一个候选位置                                   | `Content-Location: /index.htm`                               | 固定       |
| Content-MD5                 | 响应内容的二进制 MD5 散列值，以 Base64 方式编码              | Content-MD5: IDK0iSsgSW50ZWd0DiJUi==                         | 已淘汰     |
| Content-Range               | 如果是响应部分消息，表示属于完整消息的哪个部分               | Content-Range: bytes 21010-47021/47022                       | 固定       |
| Content-Type                | 当前内容的`MIME`类型                                         | Content-Type: text/html; charset=utf-8                       | 固定       |
| Date                        | 此条消息被发送时的日期和时间(以[RFC 7231](http://tools.ietf.org/html/rfc7231#section-7.1.1.1)中定义的"HTTP日期"格式来表示) | Date: Tue, 15 Nov 1994 08:12:31 GMT                          | 固定       |
| ETag                        | 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列  | ETag: "737060cd8c284d8af7ad3082f209582d"                     | 固定       |
| Expires                     | 指定一个日期/时间，超过该时间则认为此回应已经过期            | Expires: Thu, 01 Dec 1994 16:00:00 GMT                       | 固定: 标准 |
| Last-Modified               | 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) | Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT                 | 固定       |
| Link                        | 用来表示与另一个资源之间的类型关系，此类型关系是在[RFC 5988](https://tools.ietf.org/html/rfc5988)中定义 | `Link: `; rel="alternate"                                    | 固定       |
| Location                    | 用于在进行重定向，或在创建了某个新资源时使用。               | Location: http://www.itbilu.com/nodejs                       | 固定       |
| P3P                         | P3P策略相关设置                                              | P3P: CP="This is not a P3P policy!                           | 固定       |
| Pragma                      | 与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果 | `Pragma: no-cache`                                           | 固定       |
| Proxy-Authenticate          | 要求在访问代理时提供身份认证信息。                           | `Proxy-Authenticate: Basic`                                  | 固定       |
| Public-Key-Pins             | 用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值   | Public-Key-Pins: max-age=2592000; pin-sha256="……";           | 固定       |
| Refresh                     | 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。 | Refresh: 5; url=http://itbilu.com                            |            |
| Retry-After                 | 如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。 | 示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT | 固定       |
| Server                      | 服务器的名称                                                 | `Server: nginx/1.6.3`                                        | 固定       |
| Set-Cookie                  | 设置`HTTP cookie`                                            | Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1           | 固定: 标准 |
| Status                      | 通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。   | `Status: 200 OK`                                             |            |
| Trailer                     | `Trailer`用户说明传输中分块编码的编码信息                    | `Trailer: Max-Forwards`                                      | 固定       |
| Transfer-Encoding           | 用表示实体传输给用户的编码形式。包括：`chunked`、`compress`、 `deflate`、`gzip`、`identity`。 | Transfer-Encoding: chunked                                   | 固定       |
| Upgrade                     | 要求客户端升级到另一个高版本协议。                           | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               | 固定       |
| Vary                        | 告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。 | `Vary: *`                                                    | 固定       |
| Via                         | 告知代理服务器的客户端，当前响应是通过什么途径发送的。       | Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)                  | 固定       |
| Warning                     | 一般性警告，告知在实体内容体中可能存在错误。                 | Warning: 199 Miscellaneous warning                           | 固定       |
| WWW-Authenticate            | 表示在请求获取这个实体时应当使用的认证模式。                 | `WWW-Authenticate: Basic`                                    | 固定       |

## HTTP 完整请求

一次完整的`HTTP`的请求几个关键的点：域名解析、连接处理、系统分层。

* `DNS`域名解析，将请求域名解析为`IP`地址。
* 与IP地址对应的服务器网卡建立连接，`TCP`的三次握手，连接建立并占用。
* 服务器操作系统通过连接读取和处理请求。
* 服务器操作系统将HTTP请求转发给WEB Server或者Application Server。
* Application进行业务逻辑处理并准备响应Response。
* Response准备完成，Response通过网卡回写到用户的浏览器（IO密集）。
* TCP连接三次挥手，断开连接。

## OSI 七层模型

`OSI`（`Open System Interconnection Model`）模型，开放式系统互联模型，使各种计算机在世界范围内互连为网络的标准框架。

`OSI`定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）,即`ISO`（国际标准化组织）开放互连系统参考模型。

![img](PHP系统知识.assets/70-20201019141155824.png)



第四层，传输层：定义传输数据的协议端口号以及流控和差错校验。

传输层的协议有：TCP、UDP。数据包一旦离开网卡将会进入网络传输层。



第七层，应用层：网络服务与最终用户的一个接口。

应用层的协议有：HTTP、FTP、TFTP、SMTP、SNMP、DNS、TELNET、HTTPS、POP3、DHCP。

## TCP/IP 四层模型

* 第一层：应用层，主要有负责`web`浏览器的`HTTP`协议， 文件传输的`FTP`协议，负责电子邮件的`SMTP`协议，负责域名系统的`DNS`等。
* 第二层：传输层，主要是有可靠传输的`TCP`协议，特别高效的`UDP`协议。主要负责传输应用层的数据包。
* 第三层：网络层，主要是`IP`协议。主要负责寻址（找到目标设备的位置）。
* 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。

四层网络协议的作用：

* 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。
* 接收端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。
* 层层加密和解密后，应用层最终拿到了需要的数据。

![img](PHP系统知识.assets/1739d1d409d2edf0.png)

`OSI`七层网络协议和`TCP/IP`四层协议的关系：

![img](PHP系统知识.assets/1739d1d409e3174b.png)

> 问：常见的HTTP协议、TCP协议分别位于OSI网络七层模型的第几层？

`HTTP`协议位于`OSI`网络七层模型第七层应用层。`TCP`协议位于第四层传输层。

## 工作特点和原理


## 网络协议及端口

FTP：21

Telnet：23

SMTP：25

POP3：110

HTTP：80

DNS：53



# 设计模式

## 工厂模式

## 单例模式

## 观察者模式

## 策略模式

## 适配器模式

## 注册树模式



# PHP

`PHP`版本切换：

```java

# 使用brew安装php多版本
brew install php56
brew install php70
# 安装切换工具
brew install php-version
source $(brew --prefix php-version)/php-version.sh 
# 查看当前安装的所有版本
php-version
# 切换版本
php-version 5.6.5  
```

## PHP的运行原理

请简述`CGI`、`FastCGI` 和`PHP-FPM`的区别。

> CGI 是通用网关协议，FastCGI 则是一种常驻进程的 CGI 模式程序，而 PHP-FPM 更像是管理器，用于管理FastCGI 进程。

`CGI`：通用网关接口（`Common Gateway Interface`），是`Web` 服务器和请求处理程序之间传输数据的一种标准或协议，只要遵循这个标准就可以用任何动态语言实现处理程序。`CGI`可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如`php`、`perl`、`tcl`等。

`FastCGI`：`FastCGI` 是一个常驻(`long-live`)型的`CGI`，需要单独启动，启动`FastCGI`后，会生成一个`FastCGI`主进程和多个子进程（子进程其实就是`CGI`解释器进程），它可以一直执行着，只要激活后，不会每次都要花费时间去`fork`一次(这是`CGI`最为人诟病的`fork-and-execute`模式)。

`PHP-FPM`：`PHP FastCGI Process Manager`是 `PHP` 针对 `FastCGI` 协议的具体实现，它会通过用户配置来管理一批`FastCGI`进程。提供了更好的`PHP`进程管理方式，可以有效控制内存和进程、可以平滑重载`PHP`配置等。`PHP-FPM`更像是管理器，而真正衔接`Nginx`与`PHP`的则是`FastCGI`进程。



请简述针对一千万个中国居民身份证去重的方案？

## 进程和线程

#### 什么是进程？

进程（`Process`）是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。

#### 什么是线程？

线程（`Thread`）进程的一个实体，有时也被称为轻量级的进程（`Light Weight Process`，`LWP`），是`CPU`调度和分派的基本单位，是程序执行流的最小单元，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，在运行时，只是暂用一些计数器、寄存器和栈。

> 注：进程是资源分配的最小单位，线程是资源调度的最小单位。

#### 什么是协程？

协程（`Coroutines`），是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。

因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（`Fiber`），或者绿色线程（`GreenThread`）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。



![image](系统知识.assets/6765e36cc4604fba897976638af03524.jpeg)

#### 进程与线程的区别

- 进程是资源（`CPU`、内存等）分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）。
- 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。线程是共享进程中的数据的，使用相同的地址空间，因此`CPU`切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
- 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以进程间通信的方式 `IPC`（`Inter-Process Communication`）进行。不过如何处理好同步与互斥是编写多线程程序的难点。
- 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。



#### 线程和进程的区别

| 比较项   |                             线程                             |                             协程                             |
| -------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 占用资源 |                   初始单位为1MB,固定不可变                   |                初始一般为 2KB，可随需要而增大                |
| 调度所属 |                       由 OS 的内核完成                       |                          由用户完成                          |
| 切换开销 | 涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等 |            只有三个寄存器的值修改 - PC / SP / DX.            |
| 性能问题 |        资源占用太高，频繁创建销毁会带来严重的性能问题        |              资源占用小,不会带来严重的性能问题               |
| 数据同步 |            需要用锁等机制确保数据的一直性和可见性            | 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 |

#### 进程与线程的类比

类比：进程=火车，线程=车厢

- 一个进程可以包含多个线程（一辆火车包含多节车厢）
- 线程依赖于进程，它是进程中一个完整的执行路径 （车厢依赖火车，单纯的车厢无法运行）
- 进程间的通信通过`IPC`(`Inter-Process Communication`）进行,比如管道(`pipe`)、信号量(`semophore`)、消息队列(`messagequeue`) 、 套接字(`socket`)等 （一辆火车上的乘客换到另外一辆火车，需要在站点进行换乘）
- 线程间的通信通过共享内存（`Shared Memory`）、消息队列等方式进行 （同一辆火车，A车厢换到B车厢很容易）
- 创建一个进程的开销比创建一个线程开销要消耗更多的计算机资源 （采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，但是一个线程挂掉将导致整个进程挂掉（火车之间相互不影响，一个车厢断裂会影响火车运行）
- 一个线程使用共享内存时，其他线程必须等它结束，才能使用这一块内存 。多个线程同时对同一公共资源（比如全局变量）进行读写需要使用互斥锁（车厢中使用洗手间，需要上锁）
- 一个进程使用的内存地址可以限定使用量--信号量（火车上的餐厅最多同时容纳一定乘客数量，需要等有人出来才能进去）

## PHP 基础

### 运算符

#### 错误运算符



#### 运算符优先级

| 结合方向 | 运算符                                                       | 附加信息                                                     |
| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 无       | clone new                                                    | [clone](https://www.php.net/manual/zh/language.oop5.cloning.php) 和 [new](https://www.php.net/manual/zh/language.oop5.basic.php#language.oop5.basic.new) |
| 右       | `**`                                                         | [算术运算符](https://www.php.net/manual/zh/language.operators.arithmetic.php) |
| 右       | `++` `--` `~` `(int)` `(float)` `(string)` `(array)` `(object)` `(bool)` `@` | [类型](https://www.php.net/manual/zh/language.types.php)、[递增／递减](https://www.php.net/manual/zh/language.operators.increment.php)、[错误控制](https://www.php.net/manual/zh/language.operators.errorcontrol.php) |
| 无       | `instanceof`                                                 | [类型](https://www.php.net/manual/zh/language.types.php)     |
| 右       | `!`                                                          | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 左       | `*` `/` `%`                                                  | [算术运算符](https://www.php.net/manual/zh/language.operators.arithmetic.php) |
| 左       | `+` `-` `.`                                                  | [算术运算符](https://www.php.net/manual/zh/language.operators.arithmetic.php) 和 [字符串运算符](https://www.php.net/manual/zh/language.operators.string.php) |
| 左       | `<<` `>>`                                                    | [位运算符](https://www.php.net/manual/zh/language.operators.bitwise.php) |
| 无       | `<` `<=` `>` `>=`                                            | [比较运算符](https://www.php.net/manual/zh/language.operators.comparison.php) |
| 无       | `==` `!=` `===` `!==` `<>` `<=>`                             | [比较运算符](https://www.php.net/manual/zh/language.operators.comparison.php) |
| 左       | `&`                                                          | [位运算符](https://www.php.net/manual/zh/language.operators.bitwise.php) 和 [引用](https://www.php.net/manual/zh/language.references.php) |
| 左       | `^`                                                          | [位运算符](https://www.php.net/manual/zh/language.operators.bitwise.php) |
| 左       | `|`                                                          | [位运算符](https://www.php.net/manual/zh/language.operators.bitwise.php) |
| 左       | `&&`                                                         | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 左       | `||`                                                         | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 右       | `??`                                                         | [null 合并运算符](https://www.php.net/manual/zh/language.operators.comparison.php#language.operators.comparison.coalesce) |
| 左       | `? :`                                                        | [三元运算符](https://www.php.net/manual/zh/language.operators.comparison.php#language.operators.comparison.ternary) |
| 右       | `=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=` | [赋值运算符](https://www.php.net/manual/zh/language.operators.assignment.php) |
| 右       | `yield from`                                                 | [yield from](https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield.from) |
| 右       | `yield`                                                      | [yield](https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield) |
| 左       | `and`                                                        | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 左       | `xor`                                                        | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 左       | `or`                                                         | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |

基本运算符的优先级：

> 递增/递减（`++`、`--`） >  `!`（逻辑运算符）> `*` `/` `%` `+` `-` (算术运算符) > `<` `<=` `>` `>=` `==` `!=` `===` `!==` `<>` `<=>`(比较运算符) > `&` （引用运算符） > `^` `|`(位运算符) > `&&` `||`（逻辑运算符） >  `? :`（三目运算符）> `=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=` （赋值运算符） > `and` > `xor` > `or`。



经典示例（必须掌握）：

`<` `<=` `>` `>=` `==` `!=` `===` `!==` `<>` `<=>`(比较运算符)  >  `&&` `||`（逻辑运算符） > `=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=` （赋值运算符）。

```php
$a = 0;
$b = 0;
if($a = 3 > 0 || $b = 3 > 0)
{
    $a++;
    $b++;
    echo $a."\n"; // 1
    echo $b."\n"; // 1
}
```

示例1：

* [算术运算符](https://www.php.net/manual/zh/language.operators.arithmetic.php)的结合方向从左向右，优先级顺序（`*` `/` `%` `+` `-` ）。
* [三元运算符](https://www.php.net/manual/zh/language.operators.comparison.php#language.operators.comparison.ternary)的结合方向从左向右。
* [赋值运算符](https://www.php.net/manual/zh/language.operators.assignment.php)的结合方向从右向左，优先级顺序（`=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=`）

```php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
echo $a;
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2
echo $a;

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
echo $a;
```

示例2：

* 递增递减（`++`、`--`）的优先级高于算术运算符（`*` `/` `%` `+` `-`）高于赋值运算符（`=` `+=` `-=` `*=` `**=` `/=` `.=`）。

```php
$a = 1;
echo $a + $a++; // 3

$i = 1;
$array[$i] = $i++;
echo $i; // 2
```

示例3：

* **`+`、`-` 、`.` 具有相同的优先级**，结合方向从左向右。

```php
$x = 4;
// Warning: A non-numeric value encountered -1, or so I hope
echo "x minus one equals " . $x-1 . ", or so I hope\n";  
// -1, or so I hope
echo (("x minus one equals " . $x) - 1) . ", or so I hope\n"; 
// x minus one equals 3, or so I hope
echo "x minus one equals " . ($x-1) . ", or so I hope\n"; 
```

示例4：

* [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php)的结合顺序除了`!`是从右向左，其他都是从左到右，优先级顺序依次是（`!`、`&&`、`||`、`and`、`xor`、`or`）。
* [赋值运算符](https://www.php.net/manual/zh/language.operators.assignment.php)`=`的优先级高于`and`的，`and`的优先级最低。

```php
$bool = true && false;
var_dump($bool); // bool(false)

$bool = true and false;
var_dump($bool); // bool(true)
```

示例5：

* [比较运算符](https://www.php.net/manual/zh/language.operators.comparison.php)(`<` `<=` `>` `>=` `==` `!=` `===` `!==` `<>` `<=>` )的优先级高于[逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php)（`&&`、`||`、`and`、`xor`、`or`）高于[赋值运算符](https://www.php.net/manual/zh/language.operators.assignment.php)（`=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=`）的优先级。

```php
if($a=5&&$a==5){
    echo '5';
} else {
    echo 'not 5'; // Notice: Undefined variable: a  not 5
}
```

#### 递增递减运算符

* 递增/递减不影响布尔值。

```php
$a = false;
$b = true;
$c = true;
$a++;
--$b;
++$c;
var_dump($a); // bool(false)
var_dump($b); // bool(true)
var_dump($c); // bool(true)

echo $a; // 空，无任何输出
echo $b; // 1
echo $c; // 1
```

* 递增`NULL`值为1，递减`NULL`值没有效果。

```php
$a = NULL;
++ $a;
$b = NULL;
--$b;
var_dump($a); // int(1)
var_dump($b); // NULL
```



#### 逻辑运算符

| 例子      | 名称            | 结果                                                      |
| :-------- | :-------------- | :-------------------------------------------------------- |
| `$a and $b` | And（逻辑与）   | **`TRUE`**，如果 `$a` 和 `$b` 都为 **`TRUE`**。               |
| `$a or $b`  | Or（逻辑或）    | **`TRUE`**，如果 `$a` 或 `$b` 任一为 **`TRUE`**。             |
| `$a xor $b` | Xor（逻辑异或） | **`TRUE`**，如果 `$a` 或 `$b` 任一为 **`TRUE`**，但不同时是。 |
| `! $a `     | Not（逻辑非）   | **`TRUE`**，如果 `$a` 不为 **`TRUE`**。                     |
| `$a && $b ` | And（逻辑与）   | **`TRUE`**，如果 `$a` 和 `$b` 都为 **`TRUE`**。               |
| `$a || $b`  | Or（逻辑或）    | **`TRUE`**，如果 `$a` 或 `$b` 任一为 **`TRUE`**。             |

示例1：逻辑运算符的优先级顺序。

```php 
// foo() 根本没机会被调用，被运算符“短路”了
$a = (false && foo());
$b = (true || foo());
$c = (false and foo());
$d = (true or foo());

// || 的优先级高于 or
$e = false || true;
$f = false or true;
var_dump($e); // bool(true)
var_dump($f); // bool(false)

// && 的优先级高于 and
$g = true && false;
$h = true and false;
var_dump($g);  // bool(false)
var_dump($h); // bool(true)
```

示例2：逻辑运算符的结果总是返回布尔值。

```php
$a = 0 || 'wangxiong';
var_dump($a); // bool(true)
echo $a; // 1

$a = true or 'wangxiong';
var_dump($a); // bool(true)
echo $a; // 1

$a = false and 'wangxiong';
var_dump($a); // bool(false)
echo $a; // 无输出

$a = 'wangxiong' && true;
var_dump($a); // bool(true)
echo $a; // 1
```



#### 比较运输符

| 例子      | 名称           | 结果                                                         |
| :-------- | :------------- | :----------------------------------------------------------- |
| `$a == $b`  | 等于           | **`TRUE`**，如果类型转换后 `$a` 等于 `$b`。                      |
| `$a === $b` | 全等           | **`TRUE`**，如果 `$a` 等于 `$b`，并且它们的类型也相同。          |
| `$a != $b`  | 不等           | **`TRUE`**，如果类型转换后 `$a` 不等于 `$b`。                    |
| `$a <> $b`  | 不等           | **`TRUE`**，如果类型转换后 `$a` 不等于 `$b`。                    |
| `$a !== $b` | 不全等         | **`TRUE`**，如果 `$a` 不等于 `$b`，或者它们的类型不同。          |
| `$a < $b`   | 小与           | **`TRUE`**，如果 `$a` 严格小于 `$b`。                            |
| `$a > $b`  | 小于等于       | **`TRUE`**，如果 `$a` 小于或者等于 `$b`。                        |
| `$a >= $b`  | 大于等于       | **`TRUE`**，如果 `$a` 大于或者等于 `$b`。                        |
| `$a <=> $b` | 结合比较运算符 | 当`$a`小于、等于、大于`than $b`时 分别返回一个小于、等于、大于0的[integer](https://www.php.net/manual/zh/language.types.integer.php) 值。 PHP7开始提供。 |

示例1：

```php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump(1 == "wangxiong"); // 1 == 0 -> false
var_dump("1" == "00001"); // 1 == 1 -> true
var_dump("1" == "10"); // 1 == 10 -> false
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true
```

示例2：结合比较运算符。

```php
// Integers
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// Floats
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// Strings
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
 
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1
 
// Arrays
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1
 
// Objects
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 0
 
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "c"]; 
echo $a <=> $b; // -1
 
$a = (object) ["a" => "c"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 1
 
// only values are compared
$a = (object) ["a" => "b"]; 
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1
```

示例3：`==`和`===`的区别，除了比较值的相等，还比较类型是否相等。

```php
var_dump(1 == "1");     // bool(true)
var_dump(1 === "1");    // bool(false)
```

示例4：检查变量是否为空。

```php
var_dump(empty("")); // bool(true)
var_dump(empty(0)); // bool(true)
var_dump(empty(0.0)); // bool(true)
var_dump(empty("0")); // bool(true)
var_dump(empty(NULL)); // bool(true)
var_dump(empty(FALSE)); // bool(true)
var_dump(empty(array())); // bool(true)
var_dump(empty($var)); // bool(true)
```

示例5：等值判断的情况。

```php
var_dump('' == false); // bool(true)
var_dump('0' == 0); // bool(true)
var_dump(0.0 == 0); // bool(true)
var_dump(NULL  == 0); // bool(true)
var_dump(NULL  == FALSE); // bool(true)
var_dump([]  == FALSE); // bool(true)
```



### 面向对象



### 引用变量

概念：用不同的名字访问同一个变量内容，使用&表示。

未使用&（引用变量）：

```php
$a = range(0,1000);
var_dump(memory_get_usage()); // int(420312)
$b = $a;
var_dump(memory_get_usage()); // int(420315)
$a = range(0,1000);
var_dump(memory_get_usage()); // int(457232)
```

> 通过上面的示例显示，在未使用&（引用变量）时，内存在第一次和第二次并没有太大的差异，第三次则会产生较大差异。

> memory_get_usage — memory_get_usage ([ bool $real_usage = false ] ) : int 返回分配给 PHP 的内存量，单位是字节（byte）。

使用 &（引用变量）:

```php
$a = range(0,1000);
var_dump(memory_get_usage()); // int(393416)
$b = &$a;
var_dump(memory_get_usage()); // int(393448)
$a = range(0,1000);
var_dump(memory_get_usage()); // int(393448)
```

> 在使用引用传值时，`$a`被赋值时在内存中占据A内存空间，`$b=&$a` 时`$b`指向同一内存空间，当`$a`发生改变时`$b`所占据的内存空间会跟随`$a`变化，所以我们可以看到实际内存的使用并没有太大的变化。

引用的取消（不会销毁空间）：

```php
$a=1;
$b=&$a;
unset($b);
echo $a; // 1
echo $b; // Notice: Undefined variable: b 
```

> `$a`被赋值 `$b=&$a`之后`$a与$b`直行同一内存空间，当`unset($b)`时取消了`$b`对`$a`的引用，使`$b`不在指向`$a`的内存空间。

对象本身就是引用传递：

```php
class Person
{
    public $name="zhangsan";
}
$p1 =new Person;
xdebug_debug_zval('p1');
$p2 =$p1;
xdebug_debug_zval('p1');
$p2->name="lisi";
xdebug_debug_zval('p1');
```

![clipboard.png](PHP系统知识.assets/bVbgDBd.png)

> 对象被实例后经引用传递之后`$p1`、 `$p2`指向的始终是同一内存空间。

经典案例：

如下所示，当程序运行时，每一次循环结束后变量`$data`的值是什么？程序执行完成后，变量`$data`的值是什么？

```php
<?php
$data = ['a', 'b', 'c'];
foreach($data as $key => $val)
{
 $val = &$data[$key];
 var_dump($data); // ['a','b','c'] ['b','b','c'] ['b','c','c']
}
var_dump($data); // ['b','c','c']
```

### 魔术方法

* `__construct`：构造函数，创建一个对象时先调用此方法。举例：`new`一个对象时的初始化工作。
* `__destruct`：析构函数，某个对象的引用被删除或者对象被销毁的时候会调用此方法。
* `__call`：【方法重载】 ，在对象中调用一个不可访问方法时，会调用此方法。
* `__callStatic`：【方法重载】在静态上下文中调用一个不可访问方法时，会调用此方法。该方法是唯一一个静态的魔术方法。
* `__set`：【属性重载】给不可访问的属性赋值，会调用此方法。举例：批量设置私有属性（封装性）；允许在一定范围内添加属性。
* `__get` ：【属性重载】读取不可访问属性的值时，会调用此方法。
* `__isset`：【属性重载】当对不可访问属性调用 isset() 或 empty() 时，会调用此方法。
* `__unset`：【属性重载】当对不可访问属性调用 unset() 时，会调用此方法。
* ` __sleep()`：【序列化】serialize() 序列化的时候会检查该方法是否存在，存在则返回一个被序列化的变量名称数组。
*  `__wakeup()`：【反序列化】unserialize() 反序列化时候，定义反序列化后调用的方法，预先准备对象需要的资源。举例：用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。
* `__toString()`：将对象当作字符串使用时被自动调用（类型转换时，对象to 字符串）。举例：` echo $obj`，返回一个字符串。
* `__invoke()`：当将对象当作函数调用时会被自动调用。举例：

```
app->add(new APICheckMiddleWare($container));
```

* `__clone() `：对象复制的时候，会调用此方法。举例：对新克隆的对象中修改属性的值。

### 正则表达式

> 正则表达式的作用：分割、匹配、查找、替换字符串。

#### 元字符

| 元 字符 | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| $       | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。 |
| ( )     | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
| *       | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。    |
| +       | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\\+。   |
| .       | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \\\. 。  |
| [       | 标记一个中括号表达式的开始。要匹配 [，请使用\\ \[。          |
| ?       | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 |
| \       | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^       | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {       | 标记限定符表达式的开始。要匹配 {，请使用\ \{。               |
| \|      | 指明两项之间的一个选择。要匹配 \|，请使用\ \|。              |
| x(?=y)  | 匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。               |
| []      | 匹配一个集合。                                               |
| [^]     | 除了集合中的字符。                                           |
| [-]     | 0-9代表0到9之间的数字，A-Z代表A-Z之间的数字。                |

#### 限定符

| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

#### 通用原子

| 通用原子 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| \d       | 匹配一个数字。等价于[0-9]。                                  |
| \D       | 匹配一个非数字字符。等价于[\^ 0-9]。                         |
| \w       | 匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。 |
| \W       | 匹配一个非单字字符。等价于 [\^A-Za-z0-9_]。                  |
| \s       | 匹配一个空白字符，包括空格、制表符、换页符和换行符。         |
| \S       | 匹配一个非空白字符。                                         |

#### 模式修正符

正则表达式中常用的模式修正符有i、g、m、s、U、x、a、D、e 等。

| 修正符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| i      | 不区分(ignore)大小写。                                       |
| g      | 全局(global)匹配。                                           |
| m      | 多(more)行匹配。                                             |
| s      | 特殊字符圆点 . 中包含换行符。                                |
| U      | 只匹配最近的一个字符串；不重复匹配。                         |
| x      | 将模式中的空白忽略。                                         |
| A      | 强制从目标字符串开头匹配。                                   |
| D      | 如果使用$限制结尾字符，则不允许结尾有换行。                  |
| e      | 配合函数preg_replace()使用，可以把匹配来的字符串当作正则表达式执行。 |
| u      | 能够正确处理大于\uFFFF的Unicode字符，也就是说，会正确处理四个字节的UTF-16编码。 |

#### 后向引用

使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为 1，第二个为 2，以此类推。



```php
$str = '</b>wangxiong</b>';
$res = preg_replace('/<b>(.*)<\/b>/','\\1',$str);
var_dump($res); // wangxiong
```



#### 贪婪模式



#### PCRE函数

* preg_match()

* prge_match_all()

* prge_relpace()

* prge_split()

  

#### 中文匹配

`UTF-8`汉字编码范围是`0x4e00-0x9fa5`，在`ANSI(gb2312)`环境下，`0xb0-0xf7,0xa1-0xfe`。

`UTF-8`要使用u模式修正符使模式字符串被当成`UTF-8`，在`ANSI(GB2312)`环境下，要使用`chr`将`ASCII`码转换为字符。

```php
$str = '王雄';
$pattern = '/[\x{4e00}-\x{9fa5}]/u';
$match ='';
preg_match($pattern,$str,$match);
var_dump($match); // string(3) "王"
```

```php
$str = '王雄';
$pattern = '/['.chr(0xb0).'-'.chr(0xf7).']['.chr(0xa1).'-'.chr(0xfe).']/';
$match ='';
preg_match($pattern,$str,$match);
```



#### Email邮箱

首来看几个合法邮箱的例子：

- `1234@qq.com`（纯数字）
- `wang@126.com`（纯字母）
- `wang123@126.com`（数字、字母混合）
- `wang123@vip.163.com`（多级域名）
- `wang_email@outlook.com`（含下划线 `_`）
- `wang.email@gmail.com`（含英语句号 `.`）

根据对以上邮箱的观察，可将邮箱分为两部分（“@”左边和右边部分）来进行分析：

1. 左边部分可以有数字、字母、下划线（`_`）和英语句号（`.`），因此可以表示成：`[A-Za-z0-9]+([_\.][A-Za-z0-9]+)*`
2. 右边部分是域名，按照域名的规则，可以有数字、字母、短横线（`-`）和英语句号（`.`），另外顶级域名一般为 **2 ~ 6** 个英文字母（比如“cn”、“com”、“site”、“group”、“online”），故可表示为：`([A-Za-z0-9\-]+\.)+[A-Za-z]{2,6}`
3. 英语句号（`.`）是正则表达式的元字符，因此要进行转义（`\.`）。

邮箱正则表达式1：

```
/^[A-Za-z0-9]+([_\.][A-Za-z0-9]+)*@([A-Za-z0-9\-]+\.)+[A-Za-z]{2,6}$/
```

邮箱正则表达式2：

```
/^\w+([_\.]\w+)*@(\w+\.)+\w{2,6}$/
```

> 说明：`\w`匹配字母、数字、下划线，等价于`[A-Za-z0-9_]`；`+`匹配前面的表达式一次或者多次；`*`匹配前面的子表达式零次或多次；



#### 手机号码

手机号码正则：

```
/^1[3-9]\d{9}$
```



请写出一个正则表达式，取出页面中所有`img`标签中的`src`的值。

```php
$str = '<img alt="abc" id="a" src="wangxiong.png"/>';
$pattern = '/<img.*?src="(.*?)".*?\/?>/i';
$match = '';
preg_match($pattern, $str, $match);
var_dump($match[1]); // string(13) "wangxiong.png"
```



### 函数相关

* 变量的作用域和静态变量。

* 函数的参数及参数的引用传递。

* 函数的返回值及引用返回。

* 外部文件的导入。

* 系统内置函数。

  

变量的作用域和静态变量：

静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值不会消失。

static关键字，仅初始化一次，初始化时需要赋值，每次执行函数该值都会保留，static 修饰的变量是局部的，仅在函数内部有效，可以记录函数的调用次数，从而在某些条件下终止递归。



```php
$count = 5;
function getCount()
{
    static $count;
    return $count++;
}
echo $count; // 5
++$count;
echo getCount();// 什么都不会输出（echo NULL）
echo getCount(); // 1
```



函数参数的值传递：

```php
$a = 1;
function myFun($a)
{
    $a = 2;
}
myFun($a);
echo $a; // 1
```

函数参数的引用传递：

```php
$a = 1;
function myFun(&$a)
{
    $a = 2;
}
myFun($a);
echo $a; // 2
```



### 文件及目录

#### 文件读写

* fopen() 函数用来打开一个文件，打开时需指定打开模式。

```php
fopen ( string $filename , string $mode [, bool $use_include_path = false [, resource $context ]] ) : resource
```

| `mode` | 说明                                                         |
| :----- | :----------------------------------------------------------- |
| `'r'`  | 只读方式打开，将文件指针指向文件头。                         |
| `'r+'` | 读写方式打开，将文件指针指向文件头。                         |
| `'w'`  | 写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 |
| `'w+'` | 读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 |
| `'a'`  | 写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 |
| `'a+'` | 读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 |
| `'x'`  | 创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 **fopen()** 调用失败并返回 **`FALSE`**，并生成一条 **`E_WARNING`** 级别的错误信息。如果文件不存在则尝试创建之。这和给 底层的 `open(2)` 系统调用指定 `O_EXCL|O_CREAT` 标记是等价的。 |
| `'x+'` | 创建并以读写方式打开，其他的行为和 `'x'` 一样。              |

* fwrite ( resource `$handle` , string `$string` [, int `$length` ] ) : int 把 string 的内容写入文件指针 handle 处。
* fread ( resource `$handle` , int `$length` ) : string 从文件指针 `handle` 读取最多 `length` 个字节。
* fgets ( resource $handle [, int $length ] ) : string 从文件指针中读取一行。
* fgetc ( resource $handle ) : string 从文件句柄中获取一个字符。
* fclose ( resource `$handle` ) : bool  关闭一个已打开的文件指针。
* file_get_contents — 将整个文件读入一个字符串。

```php
file_get_contents ( string $filename [, bool $use_include_path = false [, resource $context [, int $offset = -1 [, int $maxlen ]]]] ) : string
```

* file_put_contents — 将一个字符串写入文件。

```php
file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] ) : int
```



#### 目录操作

* basename — 返回路径中的文件名部分。

```php
basename ( string $path [, string $suffix ] ) : string
```

* dirname — 返回路径中的目录部分。

```php 
dirname ( string $path ) : string
```

* pathinfo — 返回文件路径的信息。

```php
pathinfo ( string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] ) : mixed
```

* opendir — 打开目录句柄。

```php 
opendir ( string $path [, resource $context ] ) : resource
```

* readdir — 从目录句柄中读取条目。

```php
readdir ([ resource $dir_handle ] ) : string
```

* rewinddir — 倒回目录句柄。

```php
rewinddir ( resource $dir_handle ) : void
```

* rmdir — 删除目录。

```php
rmdir ( string $dirname [, resource $context ] ) : bool
```

* mkdir — 新建目录。

```php
mkdir ( string $pathname [, int $mode = 0777 [, bool $recursive = FALSE [, resource $context ]]] ) : bool
```

目录遍历程序示例：

```php

```



#### 文件操作

### 字符串

#### 字符串截取

* [substr(string，start，length)](https://secure.php.net/manual/zh/function.substr.php) - 返回提取的子字符串， 失败时返回 FALSE。

* [mb_substr(str，start，length，encoding)](https://secure.php.net/manual/zh/function.mb-substr.php) - 获取部分字符串,根据 start 和 length 参数返回 str 中指定的部分，按照字符数执行。

* [mb_strcut(str，start，length，encoding)](https://secure.php.net/manual/zh/function.mb-strcut.php) - 和 mb_substr() 类似，都是从字符串中提取子字符串，但是按字节数来执行，而不是字符个数。

#### 字符串替换

* [ str_replace(search，replace，subject，count)](https://secure.php.net/manual/zh/function.str-replace.php) - 子字符串替换，在subject中搜索search并替换为replace，返回替换后的数组或者字符串。

字符串替换：

```php
str_replace('wang','lens','wangxiong')  // lensxiong
```

* [substr_replace(string，replacement，start，length)](https://secure.php.net/manual/zh/function.substr-replace.php) - 字符串截取并替换，返回替换后的数组或者字符串。

隐藏7位手机号码：

```php
substr_replace(157110***5, '*******', 3, 7)  // 157*******5
```

#### 字符串查找

* [strstr(haystack，needle，before_needle)](https://secure.php.net/manual/zh/function.strstr.php) -查找字符串的首次出现，返回字符串的一部分或者 FALSE（如果未发现 needle）

返回@前面的字符串：

```php
strstr('lensxiong@gmail.com', '@', true) // lensxiong
```

* [strpos(haystack，needle，offset)](https://secure.php.net/manual/zh/function.strpos.php)  - 查找字符串首次出现的位置，返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)，查找字符串首次出现的位置。字符串位置是从0开始，而不是从1开始的。

```php
strpos('abcdef abcdef', 'b', 2) // $pos = 8, 不是 1
```

```php
$str='aAbB';
echo strpos($str,"A"); // 1
// 忽视位置偏移量之前的字符进行查找
$newstring = 'abcdef abcdef';
$pos = strpos($newstring, 'a', 1); // $pos = 7, 不是 0
```

*  [strrpos(haystack，needle，offset)](https://secure.php.net/manual/zh/function.strrpos.php) - 计算指定字符串在目标字符串中最后一次出现的位置

最后一次出现的位置，忽视位置偏移量之前的字符进行查找：

```php
strrpos('abcdef abcdef', 'b', 9)  // false
```

#### 字符串处理

* trim()：去除字符串首尾处的空白字符(或其他字符)

* strlen():返回字符串的长度

```php
echo strlen("Hello world!");//12
```


* substr()：截取字符串

```php
echo substr("Hello world!",6);//world!
```
* str_replace():字符串替换函数

```php
echo str_replace("world","Xiong","Hello world!");//Hello Xiong!
```
* strstr()：检索字符串函数

```php
echo strstr("Hello world!",111);//o world!
```
* str_repeat():字符串重复函数

```php
echo str_repeat(".",13);//.............
```
* strrpos() :查找字符串在另一个字符串中最后一次出现的位置。

```php
echo strpos("Hello world!","wo");//6
```
*  strrchr():查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。

```php
echo strrchr("Hello world!",111);//orld!
```
* substr() 函数返回字符串的一部分。

```php
echo substr("Hello world!",6,5);//world
```
* strcasecmp():比较两个字符串。(大小写不敏感)

```php
echo strcasecmp("Hello world!","HELLO WORLD!");//0
echo strcasecmp("c","b");//1 echo strcasecmp("a","b");//-1
```
* strcmp() 比较两个字符串。

```php
echo strcmp("a","A");//1 echo strcmp("He","H");//1 echo strcmp("a","b");//-1
```
* strstr()：搜索一个字符串在另一个字符串中的第一次出现。

```php
echo strstr("Hello world!",111);//o world!
```
* substr_count():计算子串在字符串中出现的次数。

```php
echo substr_count("Hello world. The world is nice","world");//2
echo substr_count("Hello world. The world is nice","l");//4
```



## PHP数组

* `implode` — 将一个一维数组的值转化为字符串。等同于`join ()`，别名 `implode()`。
* `explode` — 使用一个字符串分割另一个字符串。



## 手写代码

###  获取后缀名

字符串截取2种，数组分割3种，路径函数2种。

方法一（字符串截取）：字符串查找和截取

```php
$file = 'wang.xiong.png';
$pos = strrchr($file,'.'); //.png
echo substr($pos,1); // png
```

> strrchr — strrchr ( string `$haystack` , [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed) `$needle` ) : string 查找指定字符在字符串中的最后一次出现，该函数返回字符串的一部分。如果 `needle` 未被找到，返回 **`FALSE`**。
>
> substr — substr ( string `$string` , int `$start` [, int `$length` ] ) : string 返回字符串的子串，如果没有提供 `length`，返回的子字符串将从 `start` 位置开始直到字符串结尾。

方法二（字符串截取）：字符串查找和截取

```php
$file = 'wang.xiong.png';
$pos =  strrpos($file, '.'); // 10
echo substr($file, $pos+1); // png
```

> strrpos — strrpos ( string `$haystack` , string `$needle` [, int `$offset` = 0 ] ) : int 计算指定字符串在目标字符串中最后一次出现的位置，返回字符串 `haystack` 中 `needle` 最后一次出现的数字位置。

方法三（数组分割）：直接获取下标

```php
$file = 'wang.xiong.png';
$arr = explode('.', $file); 
echo $arr[count($arr)-1]; // png
```

方法四（数组分割）：`end`方法

```php
$file = 'wang.xiong.png';
$arr = explode('.', $file);
echo end($arr);  // png
```

> end — end ( array `&$array` ) : [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed) 将数组的内部指针指向最后一个单元，返回最后一个元素的值，或者如果是空数组则返回 **`FALSE`**。

方法五（数组分割）：`strrev `方法两次反转

```php
$file = 'wang.xiong.png';
$rev = strrev($file); // gnp.gnoix.gnaw
echo strrev(explode('.', $rev)[0]);
```

> strrev — strrev ( string `$string` ) : string 反转字符串，返回 `string` 反转后的字符串。

方法六（路径函数）：

```php
$file = 'wang.xiong.png';
echo pathinfo($file)['extension']; // echo pathinfo($file,PATHINFO_EXTENSION);
```

```php
array(4) {
  ["dirname"]=>
  string(1) "."
  ["basename"]=>
  string(14) "wang.xiong.png"
  ["extension"]=>
  string(3) "png"
  ["filename"]=>
  string(10) "wang.xiong"
}
```

> pathinfo — pathinfo ( string `$path` [, int `$options` = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] ) : [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed)  返回文件路径的信息。

### 字符串反序

编写一段用最小代价实现将字符串完全反序。例如：将 “1234567890” 转换成 “0987654321”。 （用你最熟悉的语言编写并标注简单注释, 不要使用函数）。

```php
<?php
$s = '1234567890';
$o = '';
$i = 0;
while(isset($s[$i]) && $s[$i] != null) {
    $o = $s[$i++].$o;
}
echo $o;
```



### 递归求阶乘

请用递归实现一个阶乘求值算法。例如： F(n): n=5;F(n)=5!=54321=120。

```php
<?php
function factorial($n)
{
    if ($n == 0) {
        return 1;
    } else {
        return $n * factorial($n - 1);
    }
}
```



### 蛇形驼峰转换

```php
// 蛇形命名转换为小驼峰命名
function SnakeToLowerCamel($value)
{
    $value = ucwords(str_replace(['_', '-'], ' ', $value));
    $value = str_replace(' ', '', $value);
    return lcfirst($value);
}
// 蛇形命名转换为大驼峰命名
function SnakeToUpperCamel($value)
{
    $value = ucwords(str_replace(['_', '-'], ' ', $value));
    $value = str_replace(' ', '', $value);
    return $value;
}
// 驼峰命名转换为蛇形命名
function CamelToSnake($value)
{
    // 以 UTF-8 模式删除空字符
    $value = preg_replace('/\s+/u', '', $value);
    // “?=”为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串
    // 这里的正则表达式匹配所有大写字符的前一个字符
    // preg_replace的第二个参数replacement 中可以包含后向引用 \\n 或 $n。每个这样的引用将被匹配到的第 n 个捕获子组捕获到的文本替换。 n 可以是0-99，\\0 和 $0 代表完整的模式匹配文本。捕获子组的序号计数方式为：代表捕获子组的左括号从左到右， 从1开始数。
    $value = strtolower(preg_replace('/(.)(?=[A-Z])/u', "$1_", $value));
    return $value;
}
```



推荐方式：

```php
 /**
     * 下划线转驼峰
     * @param $str
     * @return string|string[]|null
     * @author wangxiong
     */
    public static function underlineToHump($str)
    {
        $str = preg_replace_callback('/([-_]+([a-z]{1}))/i', function ($matches) {
            return strtoupper($matches[2]);
        }, $str);
        return $str;
    }

    /**
     * 驼峰转下划线
     * @param $str
     * @return string|string[]|null
     * @author wangxiong
     */
    public static function humpToUnderline($str)
    {
        $str = preg_replace_callback('/([A-Z]{1})/', function ($matches) {
            return '_' . strtolower($matches[0]);
        }, $str);
        return $str;
    }
```



> 说明：① preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换。 
> ② 通常: `$matches[0]`是完成的匹配，`$matches[1]`是第一个捕获子组的匹配，以此类推。 
> ③ 正则表达式：`[]`标记一个中括号表达式的开始与结束；`+`匹配前面的子表达式一次或多次；`{}`标记限定符的开始和结束；`/i`忽略大小写



### 交换两个变量的值

要求：不使用第三个变量实现。

方法一：

使用 `list` 方法，将数组中的值赋给一组变量。

```php
$a = 'wang';
$b = 'xiong';
list($b,$a)=array($a,$b);
echo $a, ' ', $b; // xiong wang
```

方法二：

使用`str_replace` — 子字符串替换：

```php
str_replace ( mixed $search , mixed $replace , mixed $subject [, int &$count ] ) : mixed
```

```php
$a = 'wang';
$b = 'xiong';
$a.=$b;
$b=str_replace($b,"",$a);
$a=str_replace($b,"",$a);
echo $a, ' ', $b; // xiong wang
```



## 超全局变量

### $_SERVER

| 名称                 | 描述                                                         | 示例                                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| SERVER_NAME          | 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。 | www.wwxiong.com                                              |
| SERVER_PORT          | 服务器所使用的端口号。                                       | 65420                                                        |
| SERVER_ADDR          | 服务器的 IP 地址。                                           | 127.0.0.1                                                    |
| REMOTE_ADDR          | 客户端的 IP 地址。                                           | 127.0.0.1                                                    |
| SERVER_SOFTWARE      | 服务器软件配置信息。                                         | nginx/1.15.12                                                |
| GATEWAY_INTERFACE    | 服务器使用的 CGI 规范的版本。                                | CGI/1.1                                                      |
| HTTP_REFERER         | 引导用户代理到当前页的前一页的地址。                         | xxx.com/admin/privilege.php?act=login                        |
| HTTP_ACCEPT_ENCODING | 当前请求头中 Accept-Encoding: 项的内容，如果存在的话。       | gzip, deflate, br                                            |
| HTTP_USER_AGENT      | 当前请求头中 User-Agent: 项的内容。                          | Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36 |
| HTTPS                | 是否HTTPS协议访问。                                          | On 代表 HTTPS， off 代表 HTTP                                |
| SCRIPT_FILENAME      | 当前执行脚本的绝对路径。                                     | /admin/admin/index.php                                       |
| REQUEST_METHOD       | 访问页面使用的请求方法；例如，“GET”, “HEAD”，“POST”，“PUT”。 | GET                                                          |

## include 和 require 的区别

* `require` 在一开始就加载，如果碰到错误，会给出致命错误，脚本将停止。
* `incluce` 只在用到时加载，如果碰到错误，会给出提示警告，脚本会继续。

* **`_once`** 后缀表示已加载的不加载，避免多次包含同一文件。

> 根本区别在于引用文件的重要性，底层库、很重要的文件、没有它不能继续执行，就用require；如果是其他不重要的代码就使用 incluced。

## echo、print和print_r()的区别

- [echo](https://www.php.net/manual/zh/function.echo.php) - 是一个语言结构，输出一个或多个字符串，不会换行。和 `print` 最主要的两个不同之处， 一是`echo` 接受参数列表，可以输出多个值，而`print`只有一个值；二是`echo` 没有返回值，`print`有返回值并且总是1。

- [print](https://www.php.net/manual/zh/function.print.php) - 是一个语言结构（带返回值1），用于输出字符串，`print` 实际上不是函数（而是语言结构），所以可以不用圆括号包围参数列表。和 `echo` 最主要的区别， `print` 仅支持一个参数，并总是返回 1。

- [print_r()](https://www.php.net/manual/zh/function.print-r) -是一个函数， 以易于理解的格式打印变量。`print`不能输出数组和对象，`print_r`可以输出`string`、`int`、`float`、`array`、`object`等，输出`array`时会用结构表示，默认`print_r`输出成功时返回`true`。

- [printf()](https://www.php.net/manual/zh/function.printf.php) - 输出格式化字符串。

  

`echo` 示例：

```php
<?php
echo "Sum: ", 1 + 2 ."\n";
echo "Hello ", isset($name) ? $name : "John Doe", "!"; // Sum: 3 Hello John Doe!
```

`print` 示例：

```php
<?php
$bar = ["name" => "wang xiong"];
$return  = print "this is {$bar['name']} !"."\n";
print($return); // this is wang xiong ! 1
```

`print_r `示例：

```php
<?php
print [1,2,3]; // Notice: Array to string conversion
print_r([1,2,3]); // Array ( [0] => 1 [1] => 2 [2] => 3 )
```

`printf` 示例：

```php
<?php
$num = 2.12;
printf("%.1f",$num); // 2.1
printf("%d", "17,999"); // 17
```

## session 和cookie 的区别

* 1、机制不同，`Cookie` 是客户端保持状态的方案（`HTTP`协议无状态的一种补充）；而 `Session` 是服务端保持状态的方案。
* 2、安全性，可以分析存放在本地的 `COOKIE` 并进行`COOKIE`欺骗 ，`Session` 保存在服务端比较安全。
* 3、性能不同，由于一定时间内 `Session` 是保存在服务器上的，当访问增多时，会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用`Cookie`。
* 4、大小不同，单个`Cookie`保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个`Cookie`。
* 5、`Session` 的运行依赖`Session ID`，而 `Session ID` 是存在 `Cookie` 中的，也就是说，如果浏览器禁用了 `Cookie`，`Session` 也会失效（但是可以通过其它方式实现，比如在 `url` 中传递 `Session ID`）。



##  日期格式

打印出前六个月的时间格式例如 2018-3-22 22:21:21。

```php
$date = date("Y-n-d H:i:s", strtotime("-6 month"));
```

```php
date("Y-m-d",time());       //显示格式如 2018-12-01
date("Y.m.d",time());       //显示格式如 2018.12.01
date("M d Y",time());       //显示格式如 Dec 01 2018
date("Y-m-d H:i",time());   //显示格式如 2018-12-01 12:01
```



# 高并发大流量解决方案

## 基础术语

* `PV`：`Page View`，页面浏览量或点击量，用户每一次对网站中的每个网页访问均被记录一次。用户对同一页面的多次访问，访问量累计。
* `UV`：`Unique Visitor`，独立访客。访问网站的一台电脑客户端为一个访客。同一天内相同的客户端只被计算一次。
* `IP`：`Internet Protocol`，指独立`IP`数。同一天内相同`IP`地址只被计算一次。
* `高并发`：是指可以让软件系统在一段时间内能够处理大量的请求。比如每秒钟可以完成10万个请求。通常如果一个系统的日`PV`在千万以上，就有可能是一个高并发的系统。
* `QPS`：`Queries Per Second`意思是每秒响应请求数，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。峰值每秒请求数（`QPS`）=（总 `PV` 数 * 80%）/（6小时秒数 * 20%），80%的访问量集中在20%的时间。
* `TPS`：`Transactions Per Second`意思是每秒事务数。每秒钟系统能够处理事务或交易的数量，它是衡量系统处理能力的重要指标。
* `吞吐量`：单位时间内处理的请求数量（通常由`QPS`与并发数决定）。
* `吞吐率`：单位时间内网络上传输的数据量，也可以指单位时间内处理客户请求数量。它是衡量网络性能的重要指标。通常情况下，吞吐率 “字节数/秒” 来衡量。
* `网络带宽`：网络带宽是指在单位时间（一般指的是1秒钟）内能传输的数据量。网络和高速公路类似，带宽越大，就类似高速公路的车道越多，其通行能力越强。计算带宽大小需要关注两个指标，峰值流量和页面的平均大小。日网站带宽 = PV / 统计时间（秒）* 平均页面大小（单位KB）* 8 。
* `并发连接数`：系统同时处理的请求数。不同于`QPS`是每秒的`HTTP`请求数量。

## 优化概览

高并发大流量解决方案的优化思路：

* 流量优化：例如防盗链；合理使用`CDN`加速。
* 前端优化：一是页面级优化，减少HTTP的请求（合理设置 HTTP缓存，启用浏览器缓存和静态资源过期时间缓存， CSS、 Javascript、Image 资源合并与压缩，使用异步请求）；二是代码级别的优化（Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化）；
* 服务端优化：动态语言静态化、并发处理、消息队列处理、服务端代码优化。
* 缓存层优化：数据库缓存（`Memcached`、`Redis`、`MongoDB`）
* MySQL优化：分库分表、分区操作、读写分离、SQL调优。
* 数据库架构优化：
* 服务器优化：负载均衡（Nginx的反向代理）、浏览器静态缓存（`Nginx`静态资源缓存配置策略）、图片服务器与`WEB`服务器分离。
* 架构层面优化：从架构上来说，采用前后端分离的分层架构，前端负责站点展现层（异步获取数据，响应速度提升），后端负责站点数据层（通过内网一次性返数据，性能大幅度提升）。

## 流量优化

### 防盗链

[OSS实现网站的防盗链？](https://developer.aliyun.com/article/57931)

盗链：在自己的页面上展示一些并不在自己服务器上的资源（图片、视频、音乐、软件等）。通过获得他人服务器上的资源地址，绕过别人的资源进行展示页面。

方法一：**nginx配置方式防盗链**

```nginx
location ~* ^.*\.(gif|jpg|png|swf|flv|rar|zip|doc|pdf|gz|bz2|jpeg|bmp|xls)$
{
         valid_referers none blocked server_names  *.wwxiong.com  ~\.google\. ~\.baidu\. ;
         if ($invalid_referer) {
              return 403;
              # rewrite ^/ http://xxx/xxx/404.jpg;
          }
}
```

原理：该指令会根据`Referer Header`头的内容分配一个值为0或1给全局变量`$invalid_referer`，默认值为`none`。如果`Referer Header`头不符合`valid_referers`指令设置的有效`Referer`，将被设置为1。

> `none`：表示无`Referer`值的情况。
> `blocked`：表示`Referer`值被防火墙进行伪装。
> `server_names`：表示一个或多个主机名称。

## 前端优化

### 减少 HTTP 请求

>  性能黄金法则：只有10%-20%的最终用户响应时间花在接收所请求的 HTML 文档上。剩下的80%0-90%时间花在了为 HTML 文档所引用的所有组件（图片、脚本、样式表、Flash 等）进行的 HTTP 请求上。

解决办法：改善响应时间的最简单途径就是减少组件的数量，并由此减少 `HTTP` 请求的数量。

* 使用图片地图，图片地图允许你在一个图片上关联多个 `URL`，目标`URL`的选择取决于用户单击了图片上的哪个位置。
* 使用`CSS Sprites`（`css`精灵），它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。
* 图片优化，使用`Base64`编码减少页面请求数（采用`Base64`的编码方式将图片直接嵌入到网页中，而不是从外部载入）；图片密集型网站可使用图片懒加载。
* 合并压缩`css`样式表和`js`脚本，目的是为了减少 `HTTP` 请求的数量。

### 浏览器静态缓存

对一个网站而言，`CSS`、`JavaScript`、图片等这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次`Http`请求都需要的，如果将这些文件缓存在浏览器中，可以极好的改善性能。

缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

`Nginx`静态资源缓存配置策略：

```nginx
server {
    listen       80 default_server;
    server_name  www.wwxiong.com;
    root         /app/xxx/html/mobile/;

    location ~ .*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$
    {
        expires      7d;
    }

    location ~ .*\.(?:js|css)$
    {
        expires      7d;
    }

    location ~ .*\.(?:htm|html)$
    {
        add_header Cache-Control "private, no-store, no-cache, must-revalidate, proxy-revalidate";
    }
}  
```

### 数据文件压缩

* `JavaScript` 代码的压缩：去掉多余的空格和回车、替换长变量名、简化代码写法，`script`标签放在底部，不要放在`head`标签。

* `CSS `代码的压缩：避免使用`CSS`表达式，`CSS`语义合并，删除无效的字符、代码、注释，代码语义的缩减和优化。

* `HTML` 代码的压缩：删除无用的字符，空格、换行符、制表符等；删除多余的`html`注释。

* `GZIP` 压缩：开启`gzip`目的是缩短浏览器和服务器之间传送数据的时间，减少带宽的占用，同时提升网站速度。



`Nginx`实现`gzip`压缩配置：

```nginx
server{
        listen 80;
        server_name wwxiong.com;

        gzip on;
        gzip_buffers 32 4k;
        gzip_comp_level 6;
        gzip_min_length 200;
        gzip_types application/javascript application/x-javascript text/javascript text/xml text/css;
        gzip_vary off;
}
```



### 使用 CDN 加速



#### 什么是 CDN?

`CDN`的全称是`Content Delivery Network`，即内容分发网络。它是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

#### CDN 的优势

* 加速网站的访问。
* 实现跨运营商、跨地域的全网覆盖。

互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。



#### CDN 工作原理

当用户访问已经使用了`CDN`服务的网站时，网站会利用全球负载均衡技术，将用户的访问指向到距离用户最近的正常工作的缓存服务器上，直接响应用户的请求。

其解析过程与传统解析方式的最大区别就在于网站的授权域名服务器不是以传统的轮询方式来响应本地`DNS`的解析请求，而是充分考虑用户发起请求的地点和当时网络的情况，来决定把用户的请求定向到离用户最近同时负载相对较轻的节点缓存服务器上。

通过用户定位算法和服务器健康检测算法综合后的数据，可以将用户的请求就近定向到分布在网络“边缘”的缓存服务器上，保证用户的访问能得到更及时可靠的响应。由于大量的用户访问都由分布在网络边缘的`CDN`节点缓存服务器直接响应了，这就不仅提高了用户的访问质量，同时有效地降低了源服务器的负载压力。

> `CDN`是只对网站的某一个具体的域名加速。如果同一个网站有多个域名，则访客访问加入`CDN`的域名获得加速效果，访问未加入`CDN`的域名，或者直接访问`IP`地址，则无法获得`CDN`效果。

#### CDN 应用场景

适用场景：

* 网站与应用加速。网站或者应用中大量静态资源的加速分发，如各类型图片、`html`、`css`、`js`文件等，可以通过`CDN`缓存到边缘节点上，当用户访问即可就近获取。
* 视频、大文件下载分发加速。`CDN`可以针对各类文件、在线点播视频提供下载、分发加速，比如`mp4`、`flv`视频文件或者单个文件大小在20M以上的安装包等文件。
* 直播加速。`CDN`借助负载均衡系统将将主播端采集的音视频数据推送到接近用户的数千个边缘节点，当观众端发起请求，就可以就近取得资源，减少网络抖动风险，增加直播链路稳定性和流畅性。
* 移动应用加速。`CDN`可以为移动`APP`更新文件（`apk`文件）分发，移动`APP`内图片、页面、短视频、`UGC`等内容的优化提供加速分发效果。



不适用场景：

* 适度的用户性，不适用有针对性、特定性、服务用户数较少的群体。

* 极端本地化用户群，不适用给定地理区域和本地化的用户群。

  

## 服务端优化



### 动态语言静态化

对实时性要求不高的页面，将现有的`php`等动态语言的逻辑代码生成静态`html`文件，用户访问动态脚本重定向到静态`html`文件的过程就叫动态语言静态化。



动态脚本通常会做逻辑计算和数据查询，访问量越大, 服务器压力越大；当访问量大时可能会造成`cpu`负载过高，数据库服务器压力过大，而使用静态化可以减小逻辑处理压力，降低数据库服务器查询压力。



静态化的实现方式：

* 方式一、使用模板引擎，可以使用`smarty`的缓存机制生成静态`html`缓存文件。

* 方式二、使用`ob`（输出缓冲取，`output buffering`）系列的函数。



### 并发处理

* PHP并发编程实践（PHP的Swoole扩展、消息队列、接口的并发请求）

  

##  缓存优化



#### Memcache 



#### Redis

 

## MySQL 优化

优化思路：

* 设计角度：存储引擎的选择、字段类型的选择、表设计（范式设计 `OR` 反范式设计）。
* 自身角度：索引、查询缓存、优化配置。
* 架构角度：主从复制、读写分离、负载均衡。



### 设计角度



####存储引擎的选择

* `InnoDB`支持事务，`MyISAM`不支持事务。`InnoDB`属于事务安全型存储引擎。
* `InnoDB`支持外键，`MyISAM`不支持外键。`InnoDB`支持外键约束、保证数据完整性。

* `InnoDB`支持表、行（默认）级锁，而`MyISAM`支持表级锁。`InnoDB`实现行级锁定，并发性处理较好。针对于并发性，`InnoDB`实现了`MVCC`，多版本并发控制。
* `InnoDB`按照主键顺序存储，`MyISAM`按照插入顺序存储。

* `InnoDB`是聚集索引，使用`B+Tree`作为索引结构，数据与索引使用同一个表空间文件来进行存储。`MyISAM`是非聚集索引，也是使用`B+Tree`作为索引结构，但是索引和数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。

`InnoDB`的优缺点：

> **优点：**支持事务，支持外键，并发量较大，适合大量`update`。
>
> **缺点：**查询数据相对较快，不适合大量的`select`。

`MyISAM`的优缺点：

> **优点**：查询数据相对较快，适合大量的`select`，可以全文索引。
>
> **缺点：**不支持事务，不支持外键，并发量较小，不适合大量`update`。

#### 字段类型的选择

> 规则：能小不要大； 能定不要变；能数值不要字符串。

##### 数值类型

| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| :----------- | :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
| TINYINT      | 1 byte                                   | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |



##### 日期和时间类型

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4             | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |

##### 字符串类型

| 类型       | 大小                  | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| CHAR       | 0-255 bytes           | 定长字符串                      |
| VARCHAR    | 0-65535 bytes         | 变长字符串                      |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535 bytes        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |

##### 使用细节

示例：

* `tinyint`（1 byte）、`smallint`（2 byte）、`mediumint`（3 byte）、`int`（4 byte）、`bigint`（8 byte）（既需要考虑空间问题、也需要考虑时间问题）。

* `char`（`md5`、手机号固定类型应使用）、`varchar `。

* `enum` 特定的固定的分类可以使用。

* `IP`地址的存储，可以使用整型存储，`int` `unsigned`。

* `decimal`用于存储精确数据，而`float`只能用于存储非精确数据，故精确数据最好使用`decimal`。

  

问：如何存`IP`地址。

>  通常，在保存`IPv4`地址时，一个`IPv4`最小需要7个字符，最大需要15个字符，所以，人们通常使用`VARCHAR(15)`来储存`IP`地址（`MySQL`在保存变长的字符串时，还需要额外的一个字节来保存此字符串的长度）。实际上`IP`是32位无符号整数，不是字符串，用小数点将地址分成四段的表示方法只是为了让人们阅读容易。如果使用无符号整数（`UNSIGNED INT`）来存储`IP`地址，只需要4个字节即可。`MySQL`提供了`INET_ATON()`函数和`INET_NTOA()`函数在这两种表示方法之间转换。



### 自身角度

 从`MySQL`自身的特性角度出发，主要可以从查询优化、索引优化、查询缓存、优化配置几个方面进行分析。



#### 查询优化

* limit
* 优化count()
* 优化关联查询
* 优化group by 和distinct



#### 索引优化

索引基本分类：

* 单列索引（普通索引`INDEX`、唯一索引`UNIQUE`、主键索引`PRIMARY`）
* 复合索引
* 全文索引（`FULLTEXT`）





* 复合索引的前缀原则

* like 查询%的问题

* 全表扫描优化

* or 条件索引使用情况

* 字符串类型索引失效的问题

  



### 架构角度



#### MySQL的读写分离

#### 分区以及分库分表



## 数据库架构优化

#### 主从复制

#### 读写分离

#### 双主热备

#### 负载均衡

* LVS 负载均衡

  

## Web 服务器的负载均衡





# NoSQL

## memcache 和 Redis 的区别





#  WEB 安全攻防实战







# 经典大全

## 自总结

### MySQL 事务及 ACID 特性 
归纳概括总结： 
事务（`Transaction`）是由一组`SQL`语句组成的逻辑处理单元；事务中可能包含一个或多个`SQL`语句，这些语句要么都执行，要么都不执行。事务具有`ACID`属性。

> Atomicity（原子性）:原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。事务是应用中不可再分的最小逻辑执行体。 
> Consistent（一致性）:在事务开始和完成时，数据都必须保持一致状态。 
> Isolation（隔离性）:事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 
> Durable（持久性）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。



### MySQL 三大范式 

总结口诀：

> 设计关系型数据库需要遵守设计规范格式(Normal Format)。 
> 第一范式，1NF，字段的原子性。 字段不可分。
> 第二范式，2NF，消除部分依赖（一张表只有一个目的，一条数据只做一件事情）。 必须有主键，非主键字段完全依赖主键（不能存在部分依赖）。
> 第三范式，3NF，消除传递依赖。非主键字段不能相互依赖。

NF1：字段的原子性就是指字段要达到不可拆分。

> 例如:顾客表(姓名、编号、地址、……)其中`地址`列还可以细分为国家、省、市、区等。 
> 班级表（班级名称，教室，课程时间）其中`课程时间`列还可以细分为开课时间和结课时间。

NF2：所谓的第二范式，首先要满足它是`1NF`，另外还需要包含两部分内容：一是表必须有一个主键；二是非主键字段必须完全依赖于主键，而不能只依赖于主键的一部分。

> 老师排课表（老师姓名、老师性别、班级名称、上课教室、开课时间、结课时间）这张表出现了老师信息和课程信息表，掺杂复杂的关系逻辑。如果老师信息表为主表，课程信息表为非主属性表，需要将非主信息表对主信息表的依赖消除。

NF3：所谓的第三范式，是在满足第一范式（字段的原子性）和第二范式（消除部分依赖）的基础上，再消除传递依赖，也就是非主键字段不能相互依赖。

> 注：理解`2NF`和`3NF`的关键点在于，`2NF`-某字段依赖于主键的一部分，`3NF`-某字段依赖于某个非主键字段。

> 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a-->b-->c 属性之间含有这样的关系，是不符合第三范式的。 
> 老师排课表（老师姓名、老师性别、班级名称、上课教室、开课时间、结课时间）中，有些字段（老师性别）依赖某个字段（老师姓名），另外一些字段（上课教室、开课时间、结课时间）依赖于另一个字段（班级名称），存在传递依赖（于ID）的现象。需要把不同实体的数据拆分成不同的数据表（老师信息表、老师排课表、班级信息表）。

![img](系统知识.assets/39190870.png)



学习高级-电商平台（京东）

阿里P8架构师谈：分布式架构设计(文章合集）



# MySQL

```sql
// 前一天
WHERE state = 1 AND(TO_DAYS(NOW()) - TO_DAYS(add_time)) <= 1
// 当天
WHERE state = 1 AND IFNULL(UNIX_TIMESTAMP(add_time) , 0)  >= UNIX_TIMESTAMP(CAST(SYSDATE() AS DATE)) AND IFNULL(UNIX_TIMESTAMP(add_time) , 0) <  UNIX_TIMESTAMP(CAST(SYSDATE() AS DATE) + INTERVAL 1 DAY)

```

## MySQL 优化

【MySQL优化】join 使用优化

场景再现：生产环境中一个查询评论内容的`SQL`语句执行时间长达10秒以上，`DBA`找到该慢查询语句，未优化前的`SQL`语句内容如下:

```sql
EXPLAIN SELECT
	`xx_answer`.`content` AS `answer_content`
FROM
	`xx_comment`
LEFT JOIN `xx_order_info` ON `xx_order_info`.`order_id` = `xx_comment`.`order_id`
LEFT JOIN `xx_goods` ON `xx_goods`.`goods_id` = `xx_comment`.`id_value`
LEFT JOIN `xx_suppliers` ON `xx_suppliers`.`suppliers_id` = `xx_goods`.`suppliers_id`
LEFT JOIN `xx_comment` AS `xx_answer` ON `xx_comment`.`comment_id` = `xx_answer`.`parent_id`
WHERE
	`xx_comment`.`parent_id` = 0
AND `xx_comment`.`first_is` = 1
AND `xx_goods`.`suppliers_id` IN('3' , '4' , '9')
ORDER BY
	`xx_comment`.`comment_id` DESC
LIMIT 10 OFFSET 20
```

执行`EXPLAIN`后的结果如下：

![image-20201119104523463](系统知识.assets/image-20201119104523463.png)

会发现最后一个表连接时`Extra`中存在`Using join buffer (Block Nested Loop)`（使用连接缓存，块嵌套循环的算法）。

另一个奇怪的现象是在另一个库2相同的表中执行上面同样的`SQL`语句却非常快，而且库2中表的数据量比库1中表的数据要多。两个表都有相同的字段和索引结构，`parent_id`字段也都创建了普通索引：

```sql
 KEY `parent_id` (`parent_id`)
```

使用如下语句对`parent_id`去重进行分析：

```java
select distinct(parent_id) from xx_comment;
```

分析后发现，库2表中的有79条，而库1表中的有0条，初步推断在库2的表中因`parent_id`有79条，优化器在左连接时使用了索引，而没有选择使用`Using join buffer (Block Nested Loop)`。试着在`sql` 语句优化中尝试使用强制索引`FORCE INDEX(parent_id)`如下：

```sql
EXPLAIN SELECT
	`xx_answer`.`content` AS `answer_content`
FROM
	`xx_comment` FORCE INDEX(parent_id)
LEFT JOIN `xx_order_info` ON `xx_order_info`.`order_id` = `xx_comment`.`order_id`
LEFT JOIN `xx_goods` ON `xx_goods`.`goods_id` = `xx_comment`.`id_value`
LEFT JOIN `xx_suppliers` ON `xx_suppliers`.`suppliers_id` = `xx_goods`.`suppliers_id`
LEFT JOIN `xx_comment` AS `xx_answer` ON `xx_comment`.`comment_id` = `xx_answer`.`parent_id`
WHERE
	`xx_comment`.`parent_id` = 0
AND `xx_comment`.`first_is` = 1
AND `xx_goods`.`suppliers_id` IN('3' , '4' , '9')
ORDER BY
	`xx_comment`.`comment_id` DESC
LIMIT 10 OFFSET 20
```

再次执行计划后，如下图所示：

![image-20201119104719656](系统知识.assets/image-20201119104719656.png)

经过优化前和优化后的`Explain`对比可以发现如下现象：

* `xx_comment` 表中不在使用全表扫描`ALL`，而是使用了`ref`非唯一性索引扫描，这样不会再使用`Using temporary`临时表排序和`Using filesort`文件排序，大大提升查询的效率。

* `xx_answer`表中`Extra`中也已不存在`Using join buffer (Block Nested Loop)`，执行语句后发现速度的确非常快。

问题：为何使用强制索引`FORCE INDEX(parent_id)`后，优化器就不选择`Using join buffer (Block Nested Loop)`？

在`MySQL`官方文档中 `8.8.2 EXPLAIN Output Format[3] `提到：`MySQL`使用`Nested-Loop Loin`算法处理所有的关联查询。使用这种算法，意味着这种执行模式：

* 从第一个表中读取一行，然后在第二个表、第三个表...中找到匹配的行，以此类推；

* 处理完所有关联的表后，`MySQL`将输出选定的列，如果列不在当前关联的索引树中，那么会进行回表查找完整记录；
* 继续遍历，从表中取出下一行，重复以上步骤。

> **多表`join`：**不管多少个表`join`，都是用的` Nested-Loop Join`实现的。如果有第三个`join`的表，那么会把前两个表的`join`结果集作为循环基础数据，在执行一次`Nested-Loop Join`，到第三个表中匹配数据，更多多表同理。

` join`走索引（`Index Nested-Loop Join`）：索引嵌套循环`join`，驱动表越小，复杂度越低，越能提高搜索效率。

`join`不走索引（`Block Nested-Loop Join`）：没有使用索引时，`join`连接的过程中就会用到`join buffer`，本次使用到的是`Block Nested Loop Join`，同样的也遵循驱动表越小，复杂度越低，越能提高搜索效率。

`join`使用总结：

* `join`优化的目标是尽可能减少`join`中`Nested-Loop`的循环次数，所以需要让小表做驱动表；

* 关联字段尽量走索引，这样就可以用到`Index Nested-Loop Join`了；
* 如果有`order by`，请使用驱动表的字段作为`order by`，否则会使用 `using temporary`；

* 如果不可避免要用到`BNL`算法，为了减少被驱动表多次扫描导致的对`Buffer Pool`利用率的影响，那么可以尝试把 `join_buffer_size`调大；
* 为了进一步加快`BNL`算法的执行效率，我们可以给关联条件加上索引，转换为`BKA`算法；如果加索引成本较高，那么可以通过临时表添加索引来实现；
* 如果使用的是`MySQL 8.0.18`，可以尝试使用`hash join`，如果是较低版本，也可以自己在程序中实现一个`hash join`。



### 参考文章

[MySQL多表关联之Block Nested-Loop Join](http://blog.sina.com.cn/s/blog_a1e9c7910102x1bz.html)

[SQL运行内幕：从执行原理看调优的本质](https://zhuanlan.zhihu.com/p/151689830)i