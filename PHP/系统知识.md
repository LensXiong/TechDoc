#   Git

## 命令大全

```java
git fetch // 从远程获取最新版本到本地，不会merge（合并）
git pull // 从远程获取最新版本并 merge（合并）到本地，等同于 git fetch + git merge
git checkout -- <file>... // 撤销本地文件的所有修改 （清理工作区文件）discard changes in working directory
git reset HEAD <file>  // 撤销上一次向暂存区添加的某个指定文件，不影响工作区中的该文件 unstage(暂存区到工作区)
git reset --hard // 同时撤销暂存区和工作区的修改，恢复到上一次提交的状态 等同于 git reset --hard HEAD
git reset  // 撤销上一次向暂存区添加的所有文件
```

## 错误解决

问题:

> ➜  mall git:(master) git pull  
> error: You have not concluded your merge (MERGE_HEAD exists).
> hint: Please, commit your changes before merging.
> fatal: Exiting because of unfinished merge.

解决：你还没有完成合并。有可能是之前 `pull `过代码，自动合并失败，有两种解决方法。

解决方法一：如果需要保留本地的更改，中止合并->重新合并->重新拉取。

```java
$:git merge --abort
$:git reset --merge
$:git pull
```

解决方法二：舍弃本地代码，远程版本覆盖本地版本（慎用）。

```java
$:git fetch --all
$:git reset --hard origin/master
$:git fetch
```



#  Docker

## 常用命令

```dockerfile
# 列出本机所有容器，包括终止运行的容器
docker ps -a
# 进入容器终端并且的保留为容器终端的输入形式
docker exec -it cda2919d4813 /bin/bash
# 列出镜像列表
docker images
# 获取新的镜像
docker pull ubuntu:13.10
# 删除镜像文件
docker image rm [imageName]
# 使用镜像运行容器
docker run -t -i ubuntu:13.10 /bin/bash
# 删除容器
docker rm 76f1912f92ac
```



# LINUX

* `netstat -tunlp`  用于显示 `tcp`，`udp` 的端口和进程等相关情况。
* `lsof（list open files） -i`  用于列出当前系统打开文件的工具。
* `ps（Process Status） -aux | grep xxx` 查看系统的进程状态。
* `cat /etc/redhat-release && cat /etc/lsb-release` 查看系统及其版本信息。
* `service iptables status` 查看`Centos 6.x`版本 `iptables`防火墙状态。
* `firewall-cmd --state` 查看`Centos 7.x`版本 `firewall`防火墙状态。
* `kill -signal pid`：`kill -9` 发送`SIGKILL`信号给进程，告诉进程，你被终结了，请立刻退出。



## SCP



scp /Users/hexindai/workspace/hexin-ashes/hexin-search-api/target/hexin-search-api.war root@172.20.10.25:/export/data/tomcatRoot/javasearch.hexindai.com/





## top

作用：显示当前系统正在执行的进程的相关信息，包括进程`ID`、内存占用率、`CPU`占用率等。
英文：The top program provides a dynamic real-time view of a running system.
参数：

| 参数       | 说明             |
| ---------- | ---------------- |
| -b         | 批处理           |
| -c         | 显示完整的治命令 |
| -I         | 忽略失效过程     |
| -s         | 保密模式         |
| -S         | 累积模式         |
| -i<时间>   | 设置间隔时间     |
| -u<用户名> | 指定用户名       |
| -p<进程号> | 指定进程         |
| -n<次数>   | 循环显示的次数   |

实例1：显示当前进程信息。

```linux
[root@iZrj9hb9k9jtcpp85t8ryeZ ~]# top
top - 16:55:44 up 70 days, 22:39, 2 users, load average: 0.29, 0.10, 0.07
Tasks: 83 total, 1 running, 82 sleeping, 0 stopped, 0 zombie
%Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
KiB Mem : 1016164 total, 142848 free, 216332 used, 656984 buff/cache
KiB Swap: 1048572 total, 881460 free, 167112 used. 594816 avail Mem
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
4343 root 20 0 424948 14220 3016 S 0.3 1.4 72:41.60 docker-containe
10620 root 20 0 132656 11972 9068 S 0.3 1.2 90:20.35 AliYunDun
24045 root 20 0 154600 5524 4212 S 0.3 0.5 0:00.02 sshd
1 root 20 0 199092 2804 1480 S 0.0 0.3 13:01.77 systemd
```

第一行：系统运行信息，同`uptime`命令的执行结果，详细说明如下：

| 参数                           | 说明                                               |
| ------------------------------ | -------------------------------------------------- |
| 16:55:44                       | 当前系统时间                                       |
| up 70 days, 22:39              | 当前系统已经运行的时间为70天22小时39分钟（未重启） |
| 2 users                        | 当前有两个用户登录系统                             |
| load average: 0.29, 0.10, 0.07 | 1分钟、5分钟、15分钟的负载情况为0.29,0.10,0.07     |

> 注：`load average`数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑`CPU`的数量，结果高于5的时候就表明系统在超负荷运转了。

第二行：`Tasks` — 任务（进程），具体信息说明如下：

| 参数        | 说明               |
| ----------- | ------------------ |
| 83 total    | 系统总进程数量83个 |
| 1 running   | 处于运行状态1个    |
| 82 sleeping | 处于睡眠状态82个   |
| 0 stopped   | 处于停止状态0个    |
| 0 zombie    | 处于僵尸状态0个    |

第三行：`cpu`状态信息，具体属性说明如下：

| 参数    | 说明                                     |
| ------- | ---------------------------------------- |
| 0.3 us  | 用户空间占比，0.3%                       |
| 0.3 sy  | 内核空间占比，0.3%                       |
| 0.0 ni  | 改变过优先级的进程CPU占比，0.0%          |
| 99.3 id | 空闲CPU占比，99.3%                       |
| 0.0 wa  | IO等待CPU占比，0.00%                     |
| 0.0 hi  | 硬中断（Hardware IRQ）占比，0.00%        |
| 0.0 si  | 软中断（Software Interrupts）占比，0.00% |
| 0.0 st  | 占比，0.00%                              |

第四行：内存状态统计，具体信息如下：

| 参数              | 说明                      |
| ----------------- | ------------------------- |
| 1016164 total     | 物理总内存量（1G）        |
| 142848 free       | 空闲内存量（0.13G）       |
| 216332 used       | 使用中的内存总量（0.25G） |
| 656984 buff/cache | 缓存的内存量（0.62G）     |

第五行：`swap`交换分区信息，具体信息说明如下：

| 参数          | 说明                      |
| ------------- | ------------------------- |
| 1048572 total | 交换区总量（1G）          |
| 881460 free   | 空闲的交换区总量（0.80G） |
| 167112 used   | 使用的交换区总量（0.20G） |

第六行：空行

第七行：各进程（任务）的状态监控，项目列信息说明如下：

| 列名称   | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| PID      | 进程id                                                       |
| USER     | 进程所有者                                                   |
| PR       | 进程优先级                                                   |
| NI(NICE) | 负值表示高优先级，正值表示低优先级。                         |
| VIRT     | 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES                |
| RES      | 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA    |
| SHR      | 共享内存大小，单位kb。                                       |
| S        | 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 |
| %CPU     | 上次更新到现在的CPU时间占用百分比。                          |
| %MEM     | 进程使用的物理内存百分比。                                   |
| TIME     | 进程使用的CPU时间总计，单位1/100秒。                         |
| COMMAND  | 进程名称（命令名/命令行）。                                  |

## netstat

作用：用来打印`Linux`中网络系统的状态信息，获取整个`Linux`系统的网络情况。

英文：`network statistics`, Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships.

选项：

| 选项 | 说明       | 作用                                       |
| ---- | ---------- | ------------------------------------------ |
| -a   | --all      | 显示所有连线中的Socket。                   |
| -t   | --tcp      | 显示TCP传输协议的连线状况。                |
| -u   | --udp      | 显示UDP传输协议的连线状况。                |
| -n   | --numeric  | 直接使用ip地址，而不通过域名服务器。       |
| -p   | --programs | 显示正在使用Socket的程序识别码和程序名称。 |
| -l   | -listening | 显示监控中的服务器的Socket。               |
| -e   | --extend   | 显示网络其他相关信息。                     |

实例1：禁用反向域名解析,只列出 TCP 或 UDP 协议的连接。

```linux
[root@wx /]# netstat -antu
Proto Recv-Q Send-Q Local Address Foreign Address State
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN
udp 0 0 0.0.0.0:68 0.0.0.0:*
```

实例2：只列出监听中的`nginx`连接，要求获取进程名(-p)、进程号(-p)以及用户 ID(-e)。

```linux
[root@wx /]# netstat -lnept | grep nginx
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 0 30270 13332/nginx: master
```

实例3：查看端口占用情况（redis-6379，mysql-3306）

```linux
[root@wx /]# netstat -tunpl | grep 3306
tcp6 0 0 :::3306 :::* LISTEN 22311/mysqld
```

实例4：

```powershell
[root@wangxiong domains]# netstat -tunlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      31377/php-fpm: mast 
```

实例5：

```shell
[root@hexin-c11-168 domains]# netstat -tunlp | grep java
tcp6       0      0 :::8085                 :::*                    LISTEN      22301/java          
tcp6       0      0 :::8086                 :::*                    LISTEN      22289/java          
tcp6       0      0 :::8992                 :::*                    LISTEN      4433/java
```

## lsof

`lsof(list open files)`是一个列出当前系统打开文件的工具。

`lsof `查看端口占用语法格式：

```shell
lsof -i:端口号
```

使用`-i:port`来显示与指定端口相关的网络信息：
```powershell
[root@wangxiong ~]# lsof -i:8088
COMMAND   PID  USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME
nginx   30357 admin   25u  IPv4 198359762      0t0  TCP *:radan-http (LISTEN)
nginx   30358 admin   25u  IPv4 198359762      0t0  TCP *:radan-http (LISTEN)
```

通过在`-i`后提供对应的协议来仅仅显示`TCP`或者`UDP`连接信息：

```php
[root@wangxiong ~]# lsof -iTCP
COMMAND     PID  USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME
systemd       1  root   49u  IPv4     22610      0t0  TCP *:sunrpc (LISTEN)
systemd       1  root   54u  IPv6     22612      0t0  TCP *:sunrpc (LISTEN)
```

## ps

作用：显示当前系统中进程的快照。也就是说，该命令能捕获系统在某一事件的进程状态。
英文：`processes snapshot`,report a snapshot of the current processes.

选项：

| 选项 | 说明                   | 作用                         |
| ---- | ---------------------- | ---------------------------- |
| a    | all                    | 显示所有进程                 |
| -a   | -all                   | 显示同一终端下的所有进程     |
| -A   | Identical to -e.       | 显示所有进程                 |
| -e   | Identical to -A.       | Select all processes.        |
| f    | Do full-format listing | 显示程序之间的关系           |
| u    | userlist               | 指定用户的所有进程           |
| -au  |                        | 显示本用户的详细信息         |
| -aux |                        | 显示所有包含其他使用者的行程 |

实例1：使用`cpu`和内存升序排序来过滤进程，并通过管道显示前10个结果。

```linux
[root@wx /]# ps -aux --sort -pcpu,-pmem | head -n 10
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 10620 0.2 1.1 132656 11968 ? Ssl 9月12 89:52 /usr/local/aegis/aegis_client/aegis_10_51/AliYunDun
root 25 0.1 0.0 0 0 ? S 7月24 147:03 [kswapd0]
```

实例2：使用`PS`实时监控进程状态（动态显示，每秒刷新一次）

```linux
[root@wx /]# watch -n 1 'ps -aux --sort -pcpu,-pmem | head -n 10'
```

实例3：查找特定进程的信息

```linux
[root@wx /]# ps -ef | grep nginx
[root@wx /]# ps -aux|grep nginx
```

## tar

先来弄清两个基础概念：打包和压缩。
打包：是指将一大堆文件或目录变成一个总的文件。
压缩：则是将一个大的文件通过一些压缩算法变成一个小文件。

`tar`命令可以为`linux`的文件和目录创建档案。利用`tar`，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。

语法：

```
tar(选项)(参数)
```

选项：

| 选项 | 说明                   | 作用                       |
| ---- | ---------------------- | -------------------------- |
| -x   | --extract(提取)或--get | 从备份文件中还原文件。     |
| -z   | --gzip或--ungzip       | 通过gzip指令处理备份文件。 |
| -v   | --verbose(详细)        | 显示指令执行过程。         |
| -f   | --file                 | 指定备份文件。             |
| -c   | --create               | 建立新的备份文件。         |
| -t   | --list                 | 列出备份文件的内容。       |

应用1：以 `gzip` 压缩打包`file`文件夹并命名为`file.tar.gz`（显示打包详细过程）。

```linux
[root@wx wdata] tar -czvf file.tar.gz file
```

应用2：解压`file.tar.gz`包并命名为`file`（显示解压详细过程）

```linux
[root@wx wdata] tar -xzvf file.tar.gz file
```

应用3：显示`file.tar.gz`包中的内容。

```linux
[root@wx wdata] tar -tzvf file.tar.gz
```



## find

实例1：查找超过10MB的所有`.mp3`文件，并使用一个命令删除它们 。

```linux
[root@wx /]# find / -type f -name "*.mp3" -size +10M -exec rm {} \;
```



实例2：查找当前目录下所有目录名为`CVS`的子目录的命令。

```linux
[root@wx /]# find ./CVS -maxdepth 1 -type d -print
```



## df

作用：用于显示磁盘空间使用情况。
英文：`disk free`,report file system disk space usage.

| 选项 | 说明             | 作用                 |
| ---- | ---------------- | -------------------- |
| -T   | --print-type     | 显示文件系统的形式。 |
| -h   | --human-readable | 使用人类可读的格式。 |

```linux
[root@wx server]# df -Th
文件系统 类型 容量 已用 可用 已用% 挂载点
/dev/vda1 ext4 40G 7.4G 30G 20% /
devtmpfs devtmpfs 487M 0 487M 0% /dev
tmpfs tmpfs 497M 0 497M 0% /dev/shm
tmpfs tmpfs 497M 644K 496M 1% /run
```

## du

作用：用于显示目录或文件的大小。
英文：`disk usage`,estimate file space usage.

| 选项 | 说明             | 作用                                |
| ---- | ---------------- | ----------------------------------- |
| -s   | --summarize      | 仅显示总计。                        |
| -h   | --human-readable | 以K，M，G为单位，提高信息的可读性。 |

```linux
[root@wx server]# du -sh ./*
108K    ./package.xml
165M    ./php7
8.5M    ./redis-4.0.11
1.7M    ./redis-4.0.11.tar.gz
8.9M    ./xdebug-2.6.1
```

## 系统版本

命令1：

```shell
[root@wangxiong ~]# cat /etc/redhat-release && cat /etc/lsb-release
CentOS Linux release 7.6.1810 (Core) 
cat: /etc/lsb-release: No such file or directory
```

> 如果能确定系统是Redhat或Centos：使用cat  /etc/redhat-release 这个文件。
>
> 如果能确定系统是Ubuntu : 使用/etc/lsb-release 这个文件。

命令2：

```powershell
[root@wangxiong ~]# yum -help && apt-get -help
Usage: yum [options] COMMAND
-bash: apt-get: command not found
```

> 出现 yum 的就是 Centos ；出现 apt-get 的就是 Ubuntu。
>

命令3：

```powershell
[root@wangxiong ~]# cat /etc/issue
\S
Kernel \r on an \m
```

> 出现 Ubuntu 字样为 Ubuntu，没有则是 Centos。
>

## 防火墙

`Centos 6.x`版本 `iptables`：

```powershell
// 查看防火墙，iptables: Firewall is not running. 说明防火墙没有开启。
[root@centos6 ~]# service iptables status  
// 开启防火墙
[root@centos6 ~]# service iptables start
// 关闭防火墙
[root@centos6 ~]# service iptables stop
```

`Centos 7.x`版本 `firewalld`：

> `CentOS7` 默认使用`firewalld`防火墙。如果想换回`iptables`防火墙，可关闭`firewalld`并安装`iptables`。

```powershell
// 查看firewall（关闭后显示not running，开启后显示running）
[root@centos7 ~]# firewall-cmd --state 
// 关闭firewall
[root@centos7 ~]# systemctl stop firewalld.service
// 开启firewalld
[root@centos7 ~]# systemctl start firewalld.service
// 禁止firewall开机启动
[root@centos7 ~]# systemctl disable firewalld.service
// 设置firewall开机启动
[root@wangxiong ~]# systemctl enable iptables.service
// 重启firewall使配置生效
[root@wangxiong ~]# systemctl restart iptables.service
```



# SHELL

* `nohup`：不挂断运行。

* `&`：在后台运行。

* `#!/bin/bash`：定义使用`bash`解释器来解释脚本。

* `#!/bin/sh`：定义使用`sh`解释器来解释脚本。

* `grep -v grep`：去除包含`grep`的进程行。

  ```shell
  [root@wangxiong mall] # grep --help
  -v, --invert-match        select non-matching lines
  [root@wangxiong mall]# ps aux | grep 8080
  root      1363  0.1  0.8 958080 145456 ?       Ssl  Sep15  74:33 minio server /data
  root     17798  0.0  0.0 110272   904 pts/0    S+   15:20   0:00 grep --color=auto 8080
  [root@wangxiong mall]# ps aux | grep  8080 | grep -v grep
  root      1363  0.1  0.8 958080 145456 ?       Ssl  Sep15  74:33 minio server /data
  ```

* `[ -n "$a" ] `： 判断参数是否赋值。

```shell
# 判断a这个参数是否赋值，因为没赋值，所以返回flase
if [ -n "$a" ] 
then
    echo true
else
    echo false
fi
```



```shell
#!/bin/bash

# Profile
profile=dev

# jar 包路径
jarPath=/export/data/tomcatRoot/mall

cd ${jarPath}

# PORTAL
portalPackage=portal-1.0-SNAPSHOT

portalPid=`ps aux | grep ${portalPackage} | grep -v grep | awk '{print $2}'`
if [ -n "$portalPid" ]; then
        kill -9 $portalPid;
fi

nohup java -jar -Dspring.profiles.active=${profile} ${jarPath}/mall-${portalPackage}.jar >> portal.out 2>&1 &
```



# NGINX

## 反向代理

配置 `nginx` 反向代理：

```nginx
server {
     listen          8088;
     location / {
         root  /export/admin/dist/;
         index index.html;
     }
 }

server{
    listen 80;
    server_name wwxiong.com;

    charset utf-8;

    location / {
        proxy_pass         http://127.0.0.1:8088;
        proxy_set_header   Host             $host;
        proxy_set_header   X-Real-IP        $remote_addr;
        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        proxy_http_version 1.1;
        proxy_set_header Connection "upgrade";
                proxy_set_header Upgrade $http_upgrade;
                proxy_read_timeout 120s;
    }

    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }
}
```

# 网络协议

## HTTP 请求方法

浏览器的第一步工作是对 `URL` 进行解析，当解析完成以后接下来就是浏览器需要告诉服务器进行怎样的操作，我们称之为方法。最常用的方法是`GET `和`POST`方法，除此之外还有很多其他的方法，比如`PUT `和 `DELETE` 等方法，我们需要认真思考一下它们的含义，以便理解 `HTTP` 协议具备的所有功能，以下为`HTTP`的主要方法及其含义：

| 方法    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 获取 `URI `指定的信息。如果 `URI` 指定的是文件，则返回文件的内容；如果 `URI `指定的是 `CGI `程序，则返回该程序的输出数据。 |
| POST    | 从客户端向服务器发送数据。一般用于发送表单中填写的数据等情况下。 |
| HEAD    | 和 `GET` 基本相同。不过它只返回 `HTTP` 的消息头 (`message` `header`)，而并不返回数据的内容。用于获取文件最后更新时间等属性信息。 |
| OPTIONS | 用于通知或查询通信选项。                                     |
| PUT     | 替换 `URI` 指定的服务器上的文件。如果 `URI` 指定的文件不存在，则创建该文件。 |
| DELETE  | 删除 `URI` 指定的服务器上的文件。                            |
| TRACE   | 将服务器收到的请求行和头部(`header`)直接返回给客户端。用于在使用代理的环境中检查改写请求 的情况。 |
| CONNECT | 使用代理传输加密消息时使用的方法。                           |

> 问：GET和POST 的区别？

这个问题看似很简单，其实网上的很多答案都是不正确的。从标准上来看，`GET` 和 `POST `的区别如下：

* `GET` 用于获取资源，是无副作用的，是幂等的，且可缓存。

* `POST` 用于处理资源，有副作用，非幂等，不可缓存。

可以用以下图来表示：

| 幂等性 | 改变服务器上资源的状态 | 不改变服务器上资源的状态 |
| ------ | ---------------------- | ------------------------ |
| 幂等   | PUT                    | GET                      |
| 非幂等 | POST                   | 无                       |

首先我们需要知道`RFC7231`里定义了`HTTP`方法的几个性质：


* ① `Safe` - 安全性。这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。 此`RFC`定义，`GET`、`HEAD`、 `OPTIONS` 和 `TRACE` 这几个方法是安全的。但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，比如说可以使用`GET`修改用户信息的情况。引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。`User Agent`（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。

* ② `Idempotent`- 幂等性。幂等性的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照`RFC`规范，`PUT`、`DELETE`都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退或者刷新时遇到`POST`会给用户提示的原因：`POST`语义不是幂等的，重复请求可能会带来意想不到的后果。

* ③ `Cacheable` - 可缓存性。顾名思义就是一个方法是否可以被缓存，此`RFC`里`GET`，`HEAD`和某些情况下的`POST`都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持`GET`和`HEAD`。

关于`GET`和`POST` 这两种方法的语义，`RFC7231`里原文定义如下：

> The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.

> The POST method requests that the target resource process the representation enclosed in the request according to the resource’s own specific semantics.

以下为错误的认识：

① `GET`方法对数据长度有限制而`POST`方法没有限制？事实上，`HTTP`协议明确地指出了，`HTTP`头和`Body`都没有长度的要求，对 `URL` 限制的大多是浏览器和服务器的原因。服务器是因为处理长 `URL` 要消耗比较多的资源，为了性能和安全（防止恶意构造长 `URL` 来攻击）考虑，会给 `URL` 长度加限制，如果有人恶意地构造几个几M大小的`URL`，并不停地访问你的服务器，服务器性能就会下降。

② `POST` 方法比` GET `方法安全？有人说`POST` 比`GET`安全，因为数据在地址栏上不可见。然而，从传输的角度来说，他们都是不安全的，因为 `HTTP` 在网络上是明文传输的，只要在网络节点上抓包，就能完整地获取数据报文，要想安全传输，就只有加密，也就是 `HTTPS`进行传输。

## HTTP 状态码

`HTTP` 响应消息中状态码的第一位数字表示状态类型，第二、三位数字表示具体的情况。下表列举了第一位数字的含义，`HTTP`状态码分类:

| 分类 | 分类描述                                                     |
| ---- | ------------------------------------------------------------ |
| 1xx  | 告知请求的处理进度和情况，服务器收到请求，需要请求者继续执行操作 |
| 2xx  | 成功，操作被成功接收并处理                                   |
| 3xx  | 表示需要进一步操作                                           |
| 4xx  | 客户端错误，请求包含语法错误或无法完成请求                   |
| 5xx  | 服务器错误，服务器在处理请求的过程中发生了错误               |

常用的`HTTP`状态码：

| 状态码 | 英文                  | 说明                                 |
| ------ | --------------------- | ------------------------------------ |
| 100    | Continue              | 继续。客户端应继续其请求             |
| 200    | OK                    | 请求成功                             |
| 300    | Multiple Choices      | 请求的资源可包括多个位置             |
| 301    | Moved Permanently     | 资源（网页等）被永久转移到其它URL    |
| 302    | Temporarily Moved     | 临时重定向，暂时性转移               |
| 304    | Not Modified          | 客户端已经执行了GET，但文件未变化。  |
| 400    | Bad Request           | 客户端请求的语法错误，服务器无法理解 |
| 403    | Forbidden             | 服务器已经理解请求，但是拒绝执行它   |
| 404    | Not Found             | 请求的资源（网页等）不存在           |
| 500    | Internal Server Error | 内部服务器错误                       |
| 502    | Bad Gateway           | 服务器接收到上游服务器的无效响应     |
| 504    | Gateway Time-out      | 网关超时，上游服务器超时             |

## HTTP 请求头

| 协议头              | 说明                                                         | 示例                                                    | 状态       |
| :------------------ | :----------------------------------------------------------- | :------------------------------------------------------ | :--------- |
| Accept              | 可接受的响应内容类型（`Content-Types`）。                    | `Accept: text/plain`                                    | 固定       |
| Accept-Charset      | 可接受的字符集                                               | `Accept-Charset: utf-8`                                 | 固定       |
| Accept-Encoding     | 可接受的响应内容的编码方式。                                 | `Accept-Encoding: gzip, deflate`                        | 固定       |
| Accept-Language     | 可接受的响应内容语言列表。                                   | `Accept-Language: en-US`                                | 固定       |
| Accept-Datetime     | 可接受的按照时间来表示的响应内容版本                         | Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT          | 临时       |
| Authorization       | 用于表示HTTP协议中需要认证资源的认证信息                     | Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==       | 固定       |
| Cache-Control       | 用来指定当前的请求/回复中的，是否使用缓存机制。              | `Cache-Control: no-cache`                               | 固定       |
| Connection          | 客户端（浏览器）想要优先使用的连接类型                       | `Connection: keep-alive``Connection: Upgrade`           | 固定       |
| Cookie              | 由之前服务器通过`Set-Cookie`（见下文）设置的一个HTTP协议Cookie | `Cookie: $Version=1; Skin=new;`                         | 固定：标准 |
| Content-Length      | 以8进制表示的请求体的长度                                    | `Content-Length: 348`                                   | 固定       |
| Content-MD5         | 请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果 | Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==                   | 废弃       |
| Content-Type        | 请求体的MIME类型 （用于POST和PUT请求中）                     | Content-Type: application/x-www-form-urlencoded         | 固定       |
| Date                | 发送该消息的日期和时间（以[RFC 7231](http://tools.ietf.org/html/rfc7231#section-7.1.1.1)中定义的"HTTP日期"格式来发送） | Date: Dec, 26 Dec 2015 17:30:00 GMT                     | 固定       |
| Expect              | 表示客户端要求服务器做出特定的行为                           | `Expect: 100-continue`                                  | 固定       |
| From                | 发起此请求的用户的邮件地址                                   | `From: user@itbilu.com`                                 | 固定       |
| Host                | 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。 | `Host: www.itbilu.com:80``Host: www.itbilu.com`         | 固定       |
| If-Match            | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 | If-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"            | 固定       |
| If-Modified-Since   | 允许在对应的资源未被修改的情况下返回304未修改                | If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT        | 固定       |
| If-None-Match       | 允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记 | If-None-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"       | 固定       |
| If-Range            | 如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体 | If-Range: "9jd00cdj34pss9ejqiw39d82f20d0ikd"            | 固定       |
| If-Unmodified-Since | 仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。   | If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT      | 固定       |
| Max-Forwards        | 限制该消息可被代理及网关转发的次数。                         | `Max-Forwards: 10`                                      | 固定       |
| Origin              | 发起一个针对[跨域资源共享](http://itbilu.com/javascript/js/VkiXuUcC.html)的请求（该请求要求服务器在响应中加入一个`Access-Control-Allow-Origin`的消息头，表示访问控制所允许的来源）。 | `Origin: http://www.itbilu.com`                         | 固定: 标准 |
| Pragma              | 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。 | `Pragma: no-cache`                                      | 固定       |
| Proxy-Authorization | 用于向代理进行认证的认证信息。                               | Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2== | 固定       |
| Range               | 表示请求某个实体的一部分，字节偏移以0开始。                  | `Range: bytes=500-999`                                  | 固定       |
| Referer             | 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。`Referer`其实是`Referrer`这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用`Referer`了。 | Referer: http://itbilu.com/nodejs                       | 固定       |
| TE                  | 浏览器预期接受的传输时的编码方式：可使用回应协议头`Transfer-Encoding`中的值（还可以使用"trailers"表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。 | `TE: trailers,deflate`                                  | 固定       |
| User-Agent          | 浏览器的身份标识字符串                                       | `User-Agent: Mozilla/……`                                | 固定       |
| Upgrade             | 要求服务器升级到一个高版本协议。                             | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11          | 固定       |
| Via                 | 告诉服务器，这个请求是由哪些代理发出的。                     | Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)          | 固定       |
| Warning             | 一个一般性的警告，表示在实体内容体中可能存在错误。           | Warning: 199 Miscellaneous warning                      | 固定       |

## HTTP 响应头

| 响应头                      | 说明                                                         | 示例                                                         | 状态       |
| :-------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--------- |
| Access-Control-Allow-Origin | 指定哪些网站可以`跨域源资源共享`                             | `Access-Control-Allow-Origin: *`                             | 临时       |
| Accept-Patch                | 指定服务器所支持的文档补丁格式                               | Accept-Patch: text/example;charset=utf-8                     | 固定       |
| Accept-Ranges               | 服务器所支持的内容范围                                       | `Accept-Ranges: bytes`                                       | 固定       |
| Age                         | 响应对象在代理缓存中存在的时间，以秒为单位                   | `Age: 12`                                                    | 固定       |
| Allow                       | 对于特定资源的有效动作;                                      | `Allow: GET, HEAD`                                           | 固定       |
| Cache-Control               | 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒 | `Cache-Control: max-age=3600`                                | 固定       |
| Connection                  | 针对该连接所预期的选项                                       | `Connection: close`                                          | 固定       |
| Content-Disposition         | 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。 | Content-Disposition: attachment; filename="fname.ext"        | 固定       |
| Content-Encoding            | 响应资源所使用的编码类型。                                   | `Content-Encoding: gzip`                                     | 固定       |
| Content-Language            | 响就内容所使用的语言                                         | `Content-Language: zh-cn`                                    | 固定       |
| Content-Length              | 响应消息体的长度，用8进制字节表示                            | `Content-Length: 348`                                        | 固定       |
| Content-Location            | 所返回的数据的一个候选位置                                   | `Content-Location: /index.htm`                               | 固定       |
| Content-MD5                 | 响应内容的二进制 MD5 散列值，以 Base64 方式编码              | Content-MD5: IDK0iSsgSW50ZWd0DiJUi==                         | 已淘汰     |
| Content-Range               | 如果是响应部分消息，表示属于完整消息的哪个部分               | Content-Range: bytes 21010-47021/47022                       | 固定       |
| Content-Type                | 当前内容的`MIME`类型                                         | Content-Type: text/html; charset=utf-8                       | 固定       |
| Date                        | 此条消息被发送时的日期和时间(以[RFC 7231](http://tools.ietf.org/html/rfc7231#section-7.1.1.1)中定义的"HTTP日期"格式来表示) | Date: Tue, 15 Nov 1994 08:12:31 GMT                          | 固定       |
| ETag                        | 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列  | ETag: "737060cd8c284d8af7ad3082f209582d"                     | 固定       |
| Expires                     | 指定一个日期/时间，超过该时间则认为此回应已经过期            | Expires: Thu, 01 Dec 1994 16:00:00 GMT                       | 固定: 标准 |
| Last-Modified               | 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) | Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT                 | 固定       |
| Link                        | 用来表示与另一个资源之间的类型关系，此类型关系是在[RFC 5988](https://tools.ietf.org/html/rfc5988)中定义 | `Link: `; rel="alternate"                                    | 固定       |
| Location                    | 用于在进行重定向，或在创建了某个新资源时使用。               | Location: http://www.itbilu.com/nodejs                       | 固定       |
| P3P                         | P3P策略相关设置                                              | P3P: CP="This is not a P3P policy!                           | 固定       |
| Pragma                      | 与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果 | `Pragma: no-cache`                                           | 固定       |
| Proxy-Authenticate          | 要求在访问代理时提供身份认证信息。                           | `Proxy-Authenticate: Basic`                                  | 固定       |
| Public-Key-Pins             | 用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值   | Public-Key-Pins: max-age=2592000; pin-sha256="……";           | 固定       |
| Refresh                     | 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。 | Refresh: 5; url=http://itbilu.com                            |            |
| Retry-After                 | 如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。 | 示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT | 固定       |
| Server                      | 服务器的名称                                                 | `Server: nginx/1.6.3`                                        | 固定       |
| Set-Cookie                  | 设置`HTTP cookie`                                            | Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1           | 固定: 标准 |
| Status                      | 通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。   | `Status: 200 OK`                                             |            |
| Trailer                     | `Trailer`用户说明传输中分块编码的编码信息                    | `Trailer: Max-Forwards`                                      | 固定       |
| Transfer-Encoding           | 用表示实体传输给用户的编码形式。包括：`chunked`、`compress`、 `deflate`、`gzip`、`identity`。 | Transfer-Encoding: chunked                                   | 固定       |
| Upgrade                     | 要求客户端升级到另一个高版本协议。                           | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               | 固定       |
| Vary                        | 告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。 | `Vary: *`                                                    | 固定       |
| Via                         | 告知代理服务器的客户端，当前响应是通过什么途径发送的。       | Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)                  | 固定       |
| Warning                     | 一般性警告，告知在实体内容体中可能存在错误。                 | Warning: 199 Miscellaneous warning                           | 固定       |
| WWW-Authenticate            | 表示在请求获取这个实体时应当使用的认证模式。                 | `WWW-Authenticate: Basic`                                    | 固定       |

## HTTP 完整请求

一次完整的`HTTP`的请求几个关键的点：域名解析、连接处理、系统分层。

* `DNS`域名解析，将请求域名解析为`IP`地址。
* 与IP地址对应的服务器网卡建立连接，`TCP`的三次握手，连接建立并占用。
* 服务器操作系统通过连接读取和处理请求。
* 服务器操作系统将HTTP请求转发给WEB Server或者Application Server。
* Application进行业务逻辑处理并准备响应Response。
* Response准备完成，Response通过网卡回写到用户的浏览器（IO密集）。
* TCP连接三次挥手，断开连接。

## OSI 七层模型

`OSI`（`Open System Interconnection Model`）模型，开放式系统互联模型，使各种计算机在世界范围内互连为网络的标准框架。

`OSI`定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）,即`ISO`（国际标准化组织）开放互连系统参考模型。

![img](PHP系统知识.assets/70-20201019141155824.png)



第四层，传输层：定义传输数据的协议端口号以及流控和差错校验。

传输层的协议有：TCP、UDP。数据包一旦离开网卡将会进入网络传输层。



第七层，应用层：网络服务与最终用户的一个接口。

应用层的协议有：HTTP、FTP、TFTP、SMTP、SNMP、DNS、TELNET、HTTPS、POP3、DHCP。

## TCP/IP 四层模型

* 第一层：应用层，主要有负责`web`浏览器的`HTTP`协议， 文件传输的`FTP`协议，负责电子邮件的`SMTP`协议，负责域名系统的`DNS`等。
* 第二层：传输层，主要是有可靠传输的`TCP`协议，特别高效的`UDP`协议。主要负责传输应用层的数据包。
* 第三层：网络层，主要是`IP`协议。主要负责寻址（找到目标设备的位置）。
* 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。

四层网络协议的作用：

* 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。
* 接收端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。
* 层层加密和解密后，应用层最终拿到了需要的数据。

![img](PHP系统知识.assets/1739d1d409d2edf0.png)

`OSI`七层网络协议和`TCP/IP`四层协议的关系：

![img](PHP系统知识.assets/1739d1d409e3174b.png)

> 问：常见的HTTP协议、TCP协议分别位于OSI网络七层模型的第几层？

`HTTP`协议位于`OSI`网络七层模型第七层应用层。`TCP`协议位于第四层传输层。

## 工作特点和原理


## 网络协议及端口

FTP：21

Telnet：23

SMTP：25

POP3：110

HTTP：80

DNS：53



# 设计模式

## 工厂模式

## 单例模式

## 观察者模式

## 策略模式

## 适配器模式

## 注册树模式



# PHP

## PHP的运行原理

请简述`CGI`、`FastCGI` 和`PHP-FPM`的区别。

> CGI 是通用网关协议，FastCGI 则是一种常驻进程的 CGI 模式程序，而 PHP-FPM 更像是管理器，用于管理FastCGI 进程。

`CGI`：通用网关接口（`Common Gateway Interface`），是`Web` 服务器和请求处理程序之间传输数据的一种标准或协议，只要遵循这个标准就可以用任何动态语言实现处理程序。`CGI`可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如`php`、`perl`、`tcl`等。

`FastCGI`：`FastCGI` 是一个常驻(`long-live`)型的`CGI`，需要单独启动，启动`FastCGI`后，会生成一个`FastCGI`主进程和多个子进程（子进程其实就是`CGI`解释器进程），它可以一直执行着，只要激活后，不会每次都要花费时间去`fork`一次(这是`CGI`最为人诟病的`fork-and-execute`模式)。

`PHP-FPM`：`PHP FastCGI Process Manager`是 `PHP` 针对 `FastCGI` 协议的具体实现，它会通过用户配置来管理一批`FastCGI`进程。提供了更好的`PHP`进程管理方式，可以有效控制内存和进程、可以平滑重载`PHP`配置等。`PHP-FPM`更像是管理器，而真正衔接`Nginx`与`PHP`的则是`FastCGI`进程。



请简述针对一千万个中国居民身份证去重的方案？

## 进程和线程

#### 什么是进程？

进程（`Process`）是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。

#### 什么是线程？

线程（`Thread`）进程的一个实体，有时也被称为轻量级的进程（`Light Weight Process`，`LWP`），是`CPU`调度和分派的基本单位，是程序执行流的最小单元，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，在运行时，只是暂用一些计数器、寄存器和栈。

> 注：进程是资源分配的最小单位，线程是资源调度的最小单位。

#### 什么是协程？

协程（`Coroutines`），是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。

因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（`Fiber`），或者绿色线程（`GreenThread`）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。



![image](系统知识.assets/6765e36cc4604fba897976638af03524.jpeg)

#### 进程与线程的区别

- 进程是资源（`CPU`、内存等）分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）。
- 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。线程是共享进程中的数据的，使用相同的地址空间，因此`CPU`切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
- 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以进程间通信的方式 `IPC`（`Inter-Process Communication`）进行。不过如何处理好同步与互斥是编写多线程程序的难点。
- 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。



#### 线程和进程的区别

| 比较项   |                             线程                             |                             协程                             |
| -------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 占用资源 |                   初始单位为1MB,固定不可变                   |                初始一般为 2KB，可随需要而增大                |
| 调度所属 |                       由 OS 的内核完成                       |                          由用户完成                          |
| 切换开销 | 涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等 |            只有三个寄存器的值修改 - PC / SP / DX.            |
| 性能问题 |        资源占用太高，频繁创建销毁会带来严重的性能问题        |              资源占用小,不会带来严重的性能问题               |
| 数据同步 |            需要用锁等机制确保数据的一直性和可见性            | 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 |

#### 进程与线程的类比

类比：进程=火车，线程=车厢

- 一个进程可以包含多个线程（一辆火车包含多节车厢）
- 线程依赖于进程，它是进程中一个完整的执行路径 （车厢依赖火车，单纯的车厢无法运行）
- 进程间的通信通过`IPC`(`Inter-Process Communication`）进行,比如管道(`pipe`)、信号量(`semophore`)、消息队列(`messagequeue`) 、 套接字(`socket`)等 （一辆火车上的乘客换到另外一辆火车，需要在站点进行换乘）
- 线程间的通信通过共享内存（`Shared Memory`）、消息队列等方式进行 （同一辆火车，A车厢换到B车厢很容易）
- 创建一个进程的开销比创建一个线程开销要消耗更多的计算机资源 （采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，但是一个线程挂掉将导致整个进程挂掉（火车之间相互不影响，一个车厢断裂会影响火车运行）
- 一个线程使用共享内存时，其他线程必须等它结束，才能使用这一块内存 。多个线程同时对同一公共资源（比如全局变量）进行读写需要使用互斥锁（车厢中使用洗手间，需要上锁）
- 一个进程使用的内存地址可以限定使用量--信号量（火车上的餐厅最多同时容纳一定乘客数量，需要等有人出来才能进去）

## PHP 基础

### 运算符

#### 错误运算符



#### 运算符优先级

| 结合方向 | 运算符                                                       | 附加信息                                                     |
| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 无       | clone new                                                    | [clone](https://www.php.net/manual/zh/language.oop5.cloning.php) 和 [new](https://www.php.net/manual/zh/language.oop5.basic.php#language.oop5.basic.new) |
| 右       | `**`                                                         | [算术运算符](https://www.php.net/manual/zh/language.operators.arithmetic.php) |
| 右       | `++` `--` `~` `(int)` `(float)` `(string)` `(array)` `(object)` `(bool)` `@` | [类型](https://www.php.net/manual/zh/language.types.php)、[递增／递减](https://www.php.net/manual/zh/language.operators.increment.php)、[错误控制](https://www.php.net/manual/zh/language.operators.errorcontrol.php) |
| 无       | `instanceof`                                                 | [类型](https://www.php.net/manual/zh/language.types.php)     |
| 右       | `!`                                                          | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 左       | `*` `/` `%`                                                  | [算术运算符](https://www.php.net/manual/zh/language.operators.arithmetic.php) |
| 左       | `+` `-` `.`                                                  | [算术运算符](https://www.php.net/manual/zh/language.operators.arithmetic.php) 和 [字符串运算符](https://www.php.net/manual/zh/language.operators.string.php) |
| 左       | `<<` `>>`                                                    | [位运算符](https://www.php.net/manual/zh/language.operators.bitwise.php) |
| 无       | `<` `<=` `>` `>=`                                            | [比较运算符](https://www.php.net/manual/zh/language.operators.comparison.php) |
| 无       | `==` `!=` `===` `!==` `<>` `<=>`                             | [比较运算符](https://www.php.net/manual/zh/language.operators.comparison.php) |
| 左       | `&`                                                          | [位运算符](https://www.php.net/manual/zh/language.operators.bitwise.php) 和 [引用](https://www.php.net/manual/zh/language.references.php) |
| 左       | `^`                                                          | [位运算符](https://www.php.net/manual/zh/language.operators.bitwise.php) |
| 左       | `|`                                                          | [位运算符](https://www.php.net/manual/zh/language.operators.bitwise.php) |
| 左       | `&&`                                                         | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 左       | `||`                                                         | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 右       | `??`                                                         | [null 合并运算符](https://www.php.net/manual/zh/language.operators.comparison.php#language.operators.comparison.coalesce) |
| 左       | `? :`                                                        | [三元运算符](https://www.php.net/manual/zh/language.operators.comparison.php#language.operators.comparison.ternary) |
| 右       | `=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=` | [赋值运算符](https://www.php.net/manual/zh/language.operators.assignment.php) |
| 右       | `yield from`                                                 | [yield from](https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield.from) |
| 右       | `yield`                                                      | [yield](https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield) |
| 左       | `and`                                                        | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 左       | `xor`                                                        | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |
| 左       | `or`                                                         | [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php) |

基本运算符的优先级：

> 递增/递减（`++`、`--`） >  `!`（逻辑运算符）> `*` `/` `%` `+` `-` (算术运算符) > `<` `<=` `>` `>=` `==` `!=` `===` `!==` `<>` `<=>`(比较运算符) > `&` （引用运算符） > `^` `|`(位运算符) > `&&` `||`（逻辑运算符） >  `? :`（三目运算符）> `=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=` （赋值运算符） > `and` > `xor` > `or`。



经典示例（必须掌握）：

`<` `<=` `>` `>=` `==` `!=` `===` `!==` `<>` `<=>`(比较运算符)  >  `&&` `||`（逻辑运算符） > `=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=` （赋值运算符）。

```php
$a = 0;
$b = 0;
if($a = 3 > 0 || $b = 3 > 0)
{
    $a++;
    $b++;
    echo $a."\n"; // 1
    echo $b."\n"; // 1
}
```

示例1：

* [算术运算符](https://www.php.net/manual/zh/language.operators.arithmetic.php)的结合方向从左向右，优先级顺序（`*` `/` `%` `+` `-` ）。
* [三元运算符](https://www.php.net/manual/zh/language.operators.comparison.php#language.operators.comparison.ternary)的结合方向从左向右。
* [赋值运算符](https://www.php.net/manual/zh/language.operators.assignment.php)的结合方向从右向左，优先级顺序（`=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=`）

```php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
echo $a;
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2
echo $a;

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
echo $a;
```

示例2：

* 递增递减（`++`、`--`）的优先级高于算术运算符（`*` `/` `%` `+` `-`）高于赋值运算符（`=` `+=` `-=` `*=` `**=` `/=` `.=`）。

```php
$a = 1;
echo $a + $a++; // 3

$i = 1;
$array[$i] = $i++;
echo $i; // 2
```

示例3：

* **`+`、`-` 、`.` 具有相同的优先级**，结合方向从左向右。

```php
$x = 4;
// Warning: A non-numeric value encountered -1, or so I hope
echo "x minus one equals " . $x-1 . ", or so I hope\n";  
// -1, or so I hope
echo (("x minus one equals " . $x) - 1) . ", or so I hope\n"; 
// x minus one equals 3, or so I hope
echo "x minus one equals " . ($x-1) . ", or so I hope\n"; 
```

示例4：

* [逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php)的结合顺序除了`!`是从右向左，其他都是从左到右，优先级顺序依次是（`!`、`&&`、`||`、`and`、`xor`、`or`）。
* [赋值运算符](https://www.php.net/manual/zh/language.operators.assignment.php)`=`的优先级高于`and`的，`and`的优先级最低。

```php
$bool = true && false;
var_dump($bool); // bool(false)

$bool = true and false;
var_dump($bool); // bool(true)
```

示例5：

* [比较运算符](https://www.php.net/manual/zh/language.operators.comparison.php)(`<` `<=` `>` `>=` `==` `!=` `===` `!==` `<>` `<=>` )的优先级高于[逻辑运算符](https://www.php.net/manual/zh/language.operators.logical.php)（`&&`、`||`、`and`、`xor`、`or`）高于[赋值运算符](https://www.php.net/manual/zh/language.operators.assignment.php)（`=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=`）的优先级。

```php
if($a=5&&$a==5){
    echo '5';
} else {
    echo 'not 5'; // Notice: Undefined variable: a  not 5
}
```

#### 递增递减运算符

* 递增/递减不影响布尔值。

```php
$a = false;
$b = true;
$c = true;
$a++;
--$b;
++$c;
var_dump($a); // bool(false)
var_dump($b); // bool(true)
var_dump($c); // bool(true)

echo $a; // 空，无任何输出
echo $b; // 1
echo $c; // 1
```

* 递增`NULL`值为1，递减`NULL`值没有效果。

```php
$a = NULL;
++ $a;
$b = NULL;
--$b;
var_dump($a); // int(1)
var_dump($b); // NULL
```



#### 逻辑运算符

| 例子      | 名称            | 结果                                                      |
| :-------- | :-------------- | :-------------------------------------------------------- |
| `$a and $b` | And（逻辑与）   | **`TRUE`**，如果 `$a` 和 `$b` 都为 **`TRUE`**。               |
| `$a or $b`  | Or（逻辑或）    | **`TRUE`**，如果 `$a` 或 `$b` 任一为 **`TRUE`**。             |
| `$a xor $b` | Xor（逻辑异或） | **`TRUE`**，如果 `$a` 或 `$b` 任一为 **`TRUE`**，但不同时是。 |
| `! $a `     | Not（逻辑非）   | **`TRUE`**，如果 `$a` 不为 **`TRUE`**。                     |
| `$a && $b ` | And（逻辑与）   | **`TRUE`**，如果 `$a` 和 `$b` 都为 **`TRUE`**。               |
| `$a || $b`  | Or（逻辑或）    | **`TRUE`**，如果 `$a` 或 `$b` 任一为 **`TRUE`**。             |

示例1：逻辑运算符的优先级顺序。

```php 
// foo() 根本没机会被调用，被运算符“短路”了
$a = (false && foo());
$b = (true || foo());
$c = (false and foo());
$d = (true or foo());

// || 的优先级高于 or
$e = false || true;
$f = false or true;
var_dump($e); // bool(true)
var_dump($f); // bool(false)

// && 的优先级高于 and
$g = true && false;
$h = true and false;
var_dump($g);  // bool(false)
var_dump($h); // bool(true)
```

示例2：逻辑运算符的结果总是返回布尔值。

```php
$a = 0 || 'wangxiong';
var_dump($a); // bool(true)
echo $a; // 1

$a = true or 'wangxiong';
var_dump($a); // bool(true)
echo $a; // 1

$a = false and 'wangxiong';
var_dump($a); // bool(false)
echo $a; // 无输出

$a = 'wangxiong' && true;
var_dump($a); // bool(true)
echo $a; // 1
```



#### 比较运输符

| 例子      | 名称           | 结果                                                         |
| :-------- | :------------- | :----------------------------------------------------------- |
| `$a == $b`  | 等于           | **`TRUE`**，如果类型转换后 `$a` 等于 `$b`。                      |
| `$a === $b` | 全等           | **`TRUE`**，如果 `$a` 等于 `$b`，并且它们的类型也相同。          |
| `$a != $b`  | 不等           | **`TRUE`**，如果类型转换后 `$a` 不等于 `$b`。                    |
| `$a <> $b`  | 不等           | **`TRUE`**，如果类型转换后 `$a` 不等于 `$b`。                    |
| `$a !== $b` | 不全等         | **`TRUE`**，如果 `$a` 不等于 `$b`，或者它们的类型不同。          |
| `$a < $b`   | 小与           | **`TRUE`**，如果 `$a` 严格小于 `$b`。                            |
| `$a > $b`  | 小于等于       | **`TRUE`**，如果 `$a` 小于或者等于 `$b`。                        |
| `$a >= $b`  | 大于等于       | **`TRUE`**，如果 `$a` 大于或者等于 `$b`。                        |
| `$a <=> $b` | 结合比较运算符 | 当`$a`小于、等于、大于`than $b`时 分别返回一个小于、等于、大于0的[integer](https://www.php.net/manual/zh/language.types.integer.php) 值。 PHP7开始提供。 |

示例1：

```php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump(1 == "wangxiong"); // 1 == 0 -> false
var_dump("1" == "00001"); // 1 == 1 -> true
var_dump("1" == "10"); // 1 == 10 -> false
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true
```

示例2：结合比较运算符。

```php
// Integers
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// Floats
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// Strings
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
 
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1
 
// Arrays
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1
 
// Objects
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 0
 
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "c"]; 
echo $a <=> $b; // -1
 
$a = (object) ["a" => "c"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 1
 
// only values are compared
$a = (object) ["a" => "b"]; 
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1
```

示例3：`==`和`===`的区别，除了比较值的相等，还比较类型是否相等。

```php
var_dump(1 == "1");     // bool(true)
var_dump(1 === "1");    // bool(false)
```

示例4：检查变量是否为空。

```php
var_dump(empty("")); // bool(true)
var_dump(empty(0)); // bool(true)
var_dump(empty(0.0)); // bool(true)
var_dump(empty("0")); // bool(true)
var_dump(empty(NULL)); // bool(true)
var_dump(empty(FALSE)); // bool(true)
var_dump(empty(array())); // bool(true)
var_dump(empty($var)); // bool(true)
```

示例5：等值判断的情况。

```php
var_dump('' == false); // bool(true)
var_dump('0' == 0); // bool(true)
var_dump(0.0 == 0); // bool(true)
var_dump(NULL  == 0); // bool(true)
var_dump(NULL  == FALSE); // bool(true)
var_dump([]  == FALSE); // bool(true)
```



### 面向对象



### 引用变量

概念：用不同的名字访问同一个变量内容，使用&表示。

未使用&（引用变量）：

```php
$a = range(0,1000);
var_dump(memory_get_usage()); // int(420312)
$b = $a;
var_dump(memory_get_usage()); // int(420315)
$a = range(0,1000);
var_dump(memory_get_usage()); // int(457232)
```

> 通过上面的示例显示，在未使用&（引用变量）时，内存在第一次和第二次并没有太大的差异，第三次则会产生较大差异。

> memory_get_usage — memory_get_usage ([ bool $real_usage = false ] ) : int 返回分配给 PHP 的内存量，单位是字节（byte）。

使用 &（引用变量）:

```php
$a = range(0,1000);
var_dump(memory_get_usage()); // int(393416)
$b = &$a;
var_dump(memory_get_usage()); // int(393448)
$a = range(0,1000);
var_dump(memory_get_usage()); // int(393448)
```

> 在使用引用传值时，`$a`被赋值时在内存中占据A内存空间，`$b=&$a` 时`$b`指向同一内存空间，当`$a`发生改变时`$b`所占据的内存空间会跟随`$a`变化，所以我们可以看到实际内存的使用并没有太大的变化。

引用的取消（不会销毁空间）：

```php
$a=1;
$b=&$a;
unset($b);
echo $a; // 1
echo $b; // Notice: Undefined variable: b 
```

> `$a`被赋值 `$b=&$a`之后`$a与$b`直行同一内存空间，当`unset($b)`时取消了`$b`对`$a`的引用，使`$b`不在指向`$a`的内存空间。

对象本身就是引用传递：

```php
class Person
{
    public $name="zhangsan";
}
$p1 =new Person;
xdebug_debug_zval('p1');
$p2 =$p1;
xdebug_debug_zval('p1');
$p2->name="lisi";
xdebug_debug_zval('p1');
```

![clipboard.png](PHP系统知识.assets/bVbgDBd.png)

> 对象被实例后经引用传递之后`$p1`、 `$p2`指向的始终是同一内存空间。

经典案例：

如下所示，当程序运行时，每一次循环结束后变量`$data`的值是什么？程序执行完成后，变量`$data`的值是什么？

```php
<?php
$data = ['a', 'b', 'c'];
foreach($data as $key => $val)
{
 $val = &$data[$key];
 var_dump($data); // ['a','b','c'] ['b','b','c'] ['b','c','c']
}
var_dump($data); // ['b','c','c']
```

### 魔术方法

* `__construct`：构造函数，创建一个对象时先调用此方法。举例：`new`一个对象时的初始化工作。
* `__destruct`：析构函数，某个对象的引用被删除或者对象被销毁的时候会调用此方法。
* `__call`：【方法重载】 ，在对象中调用一个不可访问方法时，会调用此方法。
* `__callStatic`：【方法重载】在静态上下文中调用一个不可访问方法时，会调用此方法。该方法是唯一一个静态的魔术方法。
* `__set`：【属性重载】给不可访问的属性赋值，会调用此方法。举例：批量设置私有属性（封装性）；允许在一定范围内添加属性。
* `__get` ：【属性重载】读取不可访问属性的值时，会调用此方法。
* `__isset`：【属性重载】当对不可访问属性调用 isset() 或 empty() 时，会调用此方法。
* `__unset`：【属性重载】当对不可访问属性调用 unset() 时，会调用此方法。
* ` __sleep()`：【序列化】serialize() 序列化的时候会检查该方法是否存在，存在则返回一个被序列化的变量名称数组。
*  `__wakeup()`：【反序列化】unserialize() 反序列化时候，定义反序列化后调用的方法，预先准备对象需要的资源。举例：用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。
* `__toString()`：将对象当作字符串使用时被自动调用（类型转换时，对象to 字符串）。举例：` echo $obj`，返回一个字符串。
* `__invoke()`：当将对象当作函数调用时会被自动调用。举例：

```
app->add(new APICheckMiddleWare($container));
```

* `__clone() `：对象复制的时候，会调用此方法。举例：对新克隆的对象中修改属性的值。

### 正则表达式

> 正则表达式的作用：分割、匹配、查找、替换字符串。

#### 元字符

| 元 字符 | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| $       | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。 |
| ( )     | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
| *       | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。    |
| +       | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\\+。   |
| .       | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \\\. 。  |
| [       | 标记一个中括号表达式的开始。要匹配 [，请使用\\ \[。          |
| ?       | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 |
| \       | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^       | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {       | 标记限定符表达式的开始。要匹配 {，请使用\ \{。               |
| \|      | 指明两项之间的一个选择。要匹配 \|，请使用\ \|。              |
| x(?=y)  | 匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。               |
| []      | 匹配一个集合。                                               |
| [^]     | 除了集合中的字符。                                           |
| [-]     | 0-9代表0到9之间的数字，A-Z代表A-Z之间的数字。                |

#### 限定符

| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

#### 通用原子

| 通用原子 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| \d       | 匹配一个数字。等价于[0-9]。                                  |
| \D       | 匹配一个非数字字符。等价于[\^ 0-9]。                         |
| \w       | 匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。 |
| \W       | 匹配一个非单字字符。等价于 [\^A-Za-z0-9_]。                  |
| \s       | 匹配一个空白字符，包括空格、制表符、换页符和换行符。         |
| \S       | 匹配一个非空白字符。                                         |

#### 模式修正符

正则表达式中常用的模式修正符有i、g、m、s、U、x、a、D、e 等。

| 修正符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| i      | 不区分(ignore)大小写。                                       |
| g      | 全局(global)匹配。                                           |
| m      | 多(more)行匹配。                                             |
| s      | 特殊字符圆点 . 中包含换行符。                                |
| U      | 只匹配最近的一个字符串；不重复匹配。                         |
| x      | 将模式中的空白忽略。                                         |
| A      | 强制从目标字符串开头匹配。                                   |
| D      | 如果使用$限制结尾字符，则不允许结尾有换行。                  |
| e      | 配合函数preg_replace()使用，可以把匹配来的字符串当作正则表达式执行。 |
| u      | 能够正确处理大于\uFFFF的Unicode字符，也就是说，会正确处理四个字节的UTF-16编码。 |

#### 后向引用

使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为 1，第二个为 2，以此类推。



```php
$str = '</b>wangxiong</b>';
$res = preg_replace('/<b>(.*)<\/b>/','\\1',$str);
var_dump($res); // wangxiong
```



#### 贪婪模式



#### PCRE函数

* preg_match()

* prge_match_all()

* prge_relpace()

* prge_split()

  

#### 中文匹配

`UTF-8`汉字编码范围是`0x4e00-0x9fa5`，在`ANSI(gb2312)`环境下，`0xb0-0xf7,0xa1-0xfe`。

`UTF-8`要使用u模式修正符使模式字符串被当成`UTF-8`，在`ANSI(GB2312)`环境下，要使用`chr`将`ASCII`码转换为字符。

```php
$str = '王雄';
$pattern = '/[\x{4e00}-\x{9fa5}]/u';
$match ='';
preg_match($pattern,$str,$match);
var_dump($match); // string(3) "王"
```

```php
$str = '王雄';
$pattern = '/['.chr(0xb0).'-'.chr(0xf7).']['.chr(0xa1).'-'.chr(0xfe).']/';
$match ='';
preg_match($pattern,$str,$match);
```



#### Email邮箱

首来看几个合法邮箱的例子：

- `1234@qq.com`（纯数字）
- `wang@126.com`（纯字母）
- `wang123@126.com`（数字、字母混合）
- `wang123@vip.163.com`（多级域名）
- `wang_email@outlook.com`（含下划线 `_`）
- `wang.email@gmail.com`（含英语句号 `.`）

根据对以上邮箱的观察，可将邮箱分为两部分（“@”左边和右边部分）来进行分析：

1. 左边部分可以有数字、字母、下划线（`_`）和英语句号（`.`），因此可以表示成：`[A-Za-z0-9]+([_\.][A-Za-z0-9]+)*`
2. 右边部分是域名，按照域名的规则，可以有数字、字母、短横线（`-`）和英语句号（`.`），另外顶级域名一般为 **2 ~ 6** 个英文字母（比如“cn”、“com”、“site”、“group”、“online”），故可表示为：`([A-Za-z0-9\-]+\.)+[A-Za-z]{2,6}`
3. 英语句号（`.`）是正则表达式的元字符，因此要进行转义（`\.`）。

邮箱正则表达式1：

```
/^[A-Za-z0-9]+([_\.][A-Za-z0-9]+)*@([A-Za-z0-9\-]+\.)+[A-Za-z]{2,6}$/
```

邮箱正则表达式2：

```
/^\w+([_\.]\w+)*@(\w+\.)+\w{2,6}$/
```

> 说明：`\w`匹配字母、数字、下划线，等价于`[A-Za-z0-9_]`；`+`匹配前面的表达式一次或者多次；`*`匹配前面的子表达式零次或多次；



#### 手机号码

手机号码正则：

```
/^1[3-9]\d{9}$
```



请写出一个正则表达式，取出页面中所有`img`标签中的`src`的值。

```php
$str = '<img alt="abc" id="a" src="wangxiong.png"/>';
$pattern = '/<img.*?src="(.*?)".*?\/?>/i';
$match = '';
preg_match($pattern, $str, $match);
var_dump($match[1]); // string(13) "wangxiong.png"
```



### 函数相关

* 变量的作用域和静态变量。

* 函数的参数及参数的引用传递。

* 函数的返回值及引用返回。

* 外部文件的导入。

* 系统内置函数。

  

变量的作用域和静态变量：

静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值不会消失。

static关键字，仅初始化一次，初始化时需要赋值，每次执行函数该值都会保留，static 修饰的变量是局部的，仅在函数内部有效，可以记录函数的调用次数，从而在某些条件下终止递归。



```php
$count = 5;
function getCount()
{
    static $count;
    return $count++;
}
echo $count; // 5
++$count;
echo getCount();// 什么都不会输出（echo NULL）
echo getCount(); // 1
```



函数参数的值传递：

```php
$a = 1;
function myFun($a)
{
    $a = 2;
}
myFun($a);
echo $a; // 1
```

函数参数的引用传递：

```php
$a = 1;
function myFun(&$a)
{
    $a = 2;
}
myFun($a);
echo $a; // 2
```



### 文件及目录

#### 文件读写

* fopen() 函数用来打开一个文件，打开时需指定打开模式。

```php
fopen ( string $filename , string $mode [, bool $use_include_path = false [, resource $context ]] ) : resource
```

| `mode` | 说明                                                         |
| :----- | :----------------------------------------------------------- |
| `'r'`  | 只读方式打开，将文件指针指向文件头。                         |
| `'r+'` | 读写方式打开，将文件指针指向文件头。                         |
| `'w'`  | 写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 |
| `'w+'` | 读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 |
| `'a'`  | 写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 |
| `'a+'` | 读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 |
| `'x'`  | 创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 **fopen()** 调用失败并返回 **`FALSE`**，并生成一条 **`E_WARNING`** 级别的错误信息。如果文件不存在则尝试创建之。这和给 底层的 `open(2)` 系统调用指定 `O_EXCL|O_CREAT` 标记是等价的。 |
| `'x+'` | 创建并以读写方式打开，其他的行为和 `'x'` 一样。              |

* fwrite ( resource `$handle` , string `$string` [, int `$length` ] ) : int 把 string 的内容写入文件指针 handle 处。
* fread ( resource `$handle` , int `$length` ) : string 从文件指针 `handle` 读取最多 `length` 个字节。
* fgets ( resource $handle [, int $length ] ) : string 从文件指针中读取一行。
* fgetc ( resource $handle ) : string 从文件句柄中获取一个字符。
* fclose ( resource `$handle` ) : bool  关闭一个已打开的文件指针。
* file_get_contents — 将整个文件读入一个字符串。

```php
file_get_contents ( string $filename [, bool $use_include_path = false [, resource $context [, int $offset = -1 [, int $maxlen ]]]] ) : string
```

* file_put_contents — 将一个字符串写入文件。

```php
file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] ) : int
```



#### 目录操作

* basename — 返回路径中的文件名部分。

```php
basename ( string $path [, string $suffix ] ) : string
```

* dirname — 返回路径中的目录部分。

```php 
dirname ( string $path ) : string
```

* pathinfo — 返回文件路径的信息。

```php
pathinfo ( string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] ) : mixed
```

* opendir — 打开目录句柄。

```php 
opendir ( string $path [, resource $context ] ) : resource
```

* readdir — 从目录句柄中读取条目。

```php
readdir ([ resource $dir_handle ] ) : string
```

* rewinddir — 倒回目录句柄。

```php
rewinddir ( resource $dir_handle ) : void
```

* rmdir — 删除目录。

```php
rmdir ( string $dirname [, resource $context ] ) : bool
```

* mkdir — 新建目录。

```php
mkdir ( string $pathname [, int $mode = 0777 [, bool $recursive = FALSE [, resource $context ]]] ) : bool
```

目录遍历程序示例：

```php

```



#### 文件操作

### 字符串

#### 字符串截取

* [substr(string，start，length)](https://secure.php.net/manual/zh/function.substr.php) - 返回提取的子字符串， 失败时返回 FALSE。

* [mb_substr(str，start，length，encoding)](https://secure.php.net/manual/zh/function.mb-substr.php) - 获取部分字符串,根据 start 和 length 参数返回 str 中指定的部分，按照字符数执行。

* [mb_strcut(str，start，length，encoding)](https://secure.php.net/manual/zh/function.mb-strcut.php) - 和 mb_substr() 类似，都是从字符串中提取子字符串，但是按字节数来执行，而不是字符个数。

#### 字符串替换

* [ str_replace(search，replace，subject，count)](https://secure.php.net/manual/zh/function.str-replace.php) - 子字符串替换，在subject中搜索search并替换为replace，返回替换后的数组或者字符串。

字符串替换：

```php
str_replace('wang','lens','wangxiong')  // lensxiong
```

* [substr_replace(string，replacement，start，length)](https://secure.php.net/manual/zh/function.substr-replace.php) - 字符串截取并替换，返回替换后的数组或者字符串。

隐藏7位手机号码：

```php
substr_replace(157110***5, '*******', 3, 7)  // 157*******5
```

#### 字符串查找

* [strstr(haystack，needle，before_needle)](https://secure.php.net/manual/zh/function.strstr.php) -查找字符串的首次出现，返回字符串的一部分或者 FALSE（如果未发现 needle）

返回@前面的字符串：

```php
strstr('lensxiong@gmail.com', '@', true) // lensxiong
```

* [strpos(haystack，needle，offset)](https://secure.php.net/manual/zh/function.strpos.php)  - 查找字符串首次出现的位置，返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)，查找字符串首次出现的位置。字符串位置是从0开始，而不是从1开始的。

```php
strpos('abcdef abcdef', 'b', 2) // $pos = 8, 不是 1
```

```php
$str='aAbB';
echo strpos($str,"A"); // 1
// 忽视位置偏移量之前的字符进行查找
$newstring = 'abcdef abcdef';
$pos = strpos($newstring, 'a', 1); // $pos = 7, 不是 0
```

*  [strrpos(haystack，needle，offset)](https://secure.php.net/manual/zh/function.strrpos.php) - 计算指定字符串在目标字符串中最后一次出现的位置

最后一次出现的位置，忽视位置偏移量之前的字符进行查找：

```php
strrpos('abcdef abcdef', 'b', 9)  // false
```

#### 字符串处理

* trim()：去除字符串首尾处的空白字符(或其他字符)

* strlen():返回字符串的长度

```php
echo strlen("Hello world!");//12
```


* substr()：截取字符串

```php
echo substr("Hello world!",6);//world!
```
* str_replace():字符串替换函数

```php
echo str_replace("world","Xiong","Hello world!");//Hello Xiong!
```
* strstr()：检索字符串函数

```php
echo strstr("Hello world!",111);//o world!
```
* str_repeat():字符串重复函数

```php
echo str_repeat(".",13);//.............
```
* strrpos() :查找字符串在另一个字符串中最后一次出现的位置。

```php
echo strpos("Hello world!","wo");//6
```
*  strrchr():查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。

```php
echo strrchr("Hello world!",111);//orld!
```
* substr() 函数返回字符串的一部分。

```php
echo substr("Hello world!",6,5);//world
```
* strcasecmp():比较两个字符串。(大小写不敏感)

```php
echo strcasecmp("Hello world!","HELLO WORLD!");//0
echo strcasecmp("c","b");//1 echo strcasecmp("a","b");//-1
```
* strcmp() 比较两个字符串。

```php
echo strcmp("a","A");//1 echo strcmp("He","H");//1 echo strcmp("a","b");//-1
```
* strstr()：搜索一个字符串在另一个字符串中的第一次出现。

```php
echo strstr("Hello world!",111);//o world!
```
* substr_count():计算子串在字符串中出现的次数。

```php
echo substr_count("Hello world. The world is nice","world");//2
echo substr_count("Hello world. The world is nice","l");//4
```



## PHP数组

* `implode` — 将一个一维数组的值转化为字符串。等同于`join ()`，别名 `implode()`。
* `explode` — 使用一个字符串分割另一个字符串。



## 手写代码

###  获取后缀名

字符串截取2种，数组分割3种，路径函数2种。

方法一（字符串截取）：字符串查找和截取

```php
$file = 'wang.xiong.png';
$pos = strrchr($file,'.'); //.png
echo substr($pos,1); // png
```

> strrchr — strrchr ( string `$haystack` , [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed) `$needle` ) : string 查找指定字符在字符串中的最后一次出现，该函数返回字符串的一部分。如果 `needle` 未被找到，返回 **`FALSE`**。
>
> substr — substr ( string `$string` , int `$start` [, int `$length` ] ) : string 返回字符串的子串，如果没有提供 `length`，返回的子字符串将从 `start` 位置开始直到字符串结尾。

方法二（字符串截取）：字符串查找和截取

```php
$file = 'wang.xiong.png';
$pos =  strrpos($file, '.'); // 10
echo substr($file, $pos+1); // png
```

> strrpos — strrpos ( string `$haystack` , string `$needle` [, int `$offset` = 0 ] ) : int 计算指定字符串在目标字符串中最后一次出现的位置，返回字符串 `haystack` 中 `needle` 最后一次出现的数字位置。

方法三（数组分割）：直接获取下标

```php
$file = 'wang.xiong.png';
$arr = explode('.', $file); 
echo $arr[count($arr)-1]; // png
```

方法四（数组分割）：`end`方法

```php
$file = 'wang.xiong.png';
$arr = explode('.', $file);
echo end($arr);  // png
```

> end — end ( array `&$array` ) : [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed) 将数组的内部指针指向最后一个单元，返回最后一个元素的值，或者如果是空数组则返回 **`FALSE`**。

方法五（数组分割）：`strrev `方法两次反转

```php
$file = 'wang.xiong.png';
$rev = strrev($file); // gnp.gnoix.gnaw
echo strrev(explode('.', $rev)[0]);
```

> strrev — strrev ( string `$string` ) : string 反转字符串，返回 `string` 反转后的字符串。

方法六（路径函数）：

```php
$file = 'wang.xiong.png';
echo pathinfo($file)['extension']; // echo pathinfo($file,PATHINFO_EXTENSION);
```

```php
array(4) {
  ["dirname"]=>
  string(1) "."
  ["basename"]=>
  string(14) "wang.xiong.png"
  ["extension"]=>
  string(3) "png"
  ["filename"]=>
  string(10) "wang.xiong"
}
```

> pathinfo — pathinfo ( string `$path` [, int `$options` = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] ) : [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed)  返回文件路径的信息。

### 字符串反序

编写一段用最小代价实现将字符串完全反序。例如：将 “1234567890” 转换成 “0987654321”。 （用你最熟悉的语言编写并标注简单注释, 不要使用函数）。

```php
<?php
$s = '1234567890';
$o = '';
$i = 0;
while(isset($s[$i]) && $s[$i] != null) {
    $o = $s[$i++].$o;
}
echo $o;
```



### 递归求阶乘

请用递归实现一个阶乘求值算法。例如： F(n): n=5;F(n)=5!=54321=120。

```php
<?php
function factorial($n)
{
    if ($n == 0) {
        return 1;
    } else {
        return $n * factorial($n - 1);
    }
}
```



### 蛇形驼峰转换

```php
// 蛇形命名转换为小驼峰命名
function SnakeToLowerCamel($value)
{
    $value = ucwords(str_replace(['_', '-'], ' ', $value));
    $value = str_replace(' ', '', $value);
    return lcfirst($value);
}
// 蛇形命名转换为大驼峰命名
function SnakeToUpperCamel($value)
{
    $value = ucwords(str_replace(['_', '-'], ' ', $value));
    $value = str_replace(' ', '', $value);
    return $value;
}
// 驼峰命名转换为蛇形命名
function CamelToSnake($value)
{
    // 以 UTF-8 模式删除空字符
    $value = preg_replace('/\s+/u', '', $value);
    // “?=”为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串
    // 这里的正则表达式匹配所有大写字符的前一个字符
    // preg_replace的第二个参数replacement 中可以包含后向引用 \\n 或 $n。每个这样的引用将被匹配到的第 n 个捕获子组捕获到的文本替换。 n 可以是0-99，\\0 和 $0 代表完整的模式匹配文本。捕获子组的序号计数方式为：代表捕获子组的左括号从左到右， 从1开始数。
    $value = strtolower(preg_replace('/(.)(?=[A-Z])/u', "$1_", $value));
    return $value;
}
```



推荐方式：

```php
 /**
     * 下划线转驼峰
     * @param $str
     * @return string|string[]|null
     * @author wangxiong
     */
    public static function underlineToHump($str)
    {
        $str = preg_replace_callback('/([-_]+([a-z]{1}))/i', function ($matches) {
            return strtoupper($matches[2]);
        }, $str);
        return $str;
    }

    /**
     * 驼峰转下划线
     * @param $str
     * @return string|string[]|null
     * @author wangxiong
     */
    public static function humpToUnderline($str)
    {
        $str = preg_replace_callback('/([A-Z]{1})/', function ($matches) {
            return '_' . strtolower($matches[0]);
        }, $str);
        return $str;
    }
```



> 说明：① preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换。 
> ② 通常: `$matches[0]`是完成的匹配，`$matches[1]`是第一个捕获子组的匹配，以此类推。 
> ③ 正则表达式：`[]`标记一个中括号表达式的开始与结束；`+`匹配前面的子表达式一次或多次；`{}`标记限定符的开始和结束；`/i`忽略大小写



### 交换两个变量的值

要求：不使用第三个变量实现。

方法一：

使用 `list` 方法，将数组中的值赋给一组变量。

```php
$a = 'wang';
$b = 'xiong';
list($b,$a)=array($a,$b);
echo $a, ' ', $b; // xiong wang
```

方法二：

使用`str_replace` — 子字符串替换：

```php
str_replace ( mixed $search , mixed $replace , mixed $subject [, int &$count ] ) : mixed
```

```php
$a = 'wang';
$b = 'xiong';
$a.=$b;
$b=str_replace($b,"",$a);
$a=str_replace($b,"",$a);
echo $a, ' ', $b; // xiong wang
```



## 超全局变量

### $_SERVER

| 名称                 | 描述                                                         | 示例                                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| SERVER_NAME          | 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。 | www.wwxiong.com                                              |
| SERVER_PORT          | 服务器所使用的端口号。                                       | 65420                                                        |
| SERVER_ADDR          | 服务器的 IP 地址。                                           | 127.0.0.1                                                    |
| REMOTE_ADDR          | 客户端的 IP 地址。                                           | 127.0.0.1                                                    |
| SERVER_SOFTWARE      | 服务器软件配置信息。                                         | nginx/1.15.12                                                |
| GATEWAY_INTERFACE    | 服务器使用的 CGI 规范的版本。                                | CGI/1.1                                                      |
| HTTP_REFERER         | 引导用户代理到当前页的前一页的地址。                         | xxx.com/admin/privilege.php?act=login                        |
| HTTP_ACCEPT_ENCODING | 当前请求头中 Accept-Encoding: 项的内容，如果存在的话。       | gzip, deflate, br                                            |
| HTTP_USER_AGENT      | 当前请求头中 User-Agent: 项的内容。                          | Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36 |
| HTTPS                | 是否HTTPS协议访问。                                          | On 代表 HTTPS， off 代表 HTTP                                |
| SCRIPT_FILENAME      | 当前执行脚本的绝对路径。                                     | /admin/admin/index.php                                       |
| REQUEST_METHOD       | 访问页面使用的请求方法；例如，“GET”, “HEAD”，“POST”，“PUT”。 | GET                                                          |

## include 和 require 的区别

* `require` 在一开始就加载，如果碰到错误，会给出致命错误，脚本将停止。
* `incluce` 只在用到时加载，如果碰到错误，会给出提示警告，脚本会继续。

* **`_once`** 后缀表示已加载的不加载，避免多次包含同一文件。

> 根本区别在于引用文件的重要性，底层库、很重要的文件、没有它不能继续执行，就用require；如果是其他不重要的代码就使用 incluced。

## echo、print和print_r()的区别

- [echo](https://www.php.net/manual/zh/function.echo.php) - 是一个语言结构，输出一个或多个字符串，不会换行。和 `print` 最主要的两个不同之处， 一是`echo` 接受参数列表，可以输出多个值，而`print`只有一个值；二是`echo` 没有返回值，`print`有返回值并且总是1。

- [print](https://www.php.net/manual/zh/function.print.php) - 是一个语言结构（带返回值1），用于输出字符串，`print` 实际上不是函数（而是语言结构），所以可以不用圆括号包围参数列表。和 `echo` 最主要的区别， `print` 仅支持一个参数，并总是返回 1。

- [print_r()](https://www.php.net/manual/zh/function.print-r) -是一个函数， 以易于理解的格式打印变量。`print`不能输出数组和对象，`print_r`可以输出`string`、`int`、`float`、`array`、`object`等，输出`array`时会用结构表示，默认`print_r`输出成功时返回`true`。

- [printf()](https://www.php.net/manual/zh/function.printf.php) - 输出格式化字符串。

  

`echo` 示例：

```php
<?php
echo "Sum: ", 1 + 2 ."\n";
echo "Hello ", isset($name) ? $name : "John Doe", "!"; // Sum: 3 Hello John Doe!
```

`print` 示例：

```php
<?php
$bar = ["name" => "wang xiong"];
$return  = print "this is {$bar['name']} !"."\n";
print($return); // this is wang xiong ! 1
```

`print_r `示例：

```php
<?php
print [1,2,3]; // Notice: Array to string conversion
print_r([1,2,3]); // Array ( [0] => 1 [1] => 2 [2] => 3 )
```

`printf` 示例：

```php
<?php
$num = 2.12;
printf("%.1f",$num); // 2.1
printf("%d", "17,999"); // 17
```

## session 和cookie 的区别

* 1、机制不同，`Cookie` 是客户端保持状态的方案（`HTTP`协议无状态的一种补充）；而 `Session` 是服务端保持状态的方案。
* 2、安全性，可以分析存放在本地的 `COOKIE` 并进行`COOKIE`欺骗 ，`Session` 保存在服务端比较安全。
* 3、性能不同，由于一定时间内 `Session` 是保存在服务器上的，当访问增多时，会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用`Cookie`。
* 4、大小不同，单个`Cookie`保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个`Cookie`。
* 5、`Session` 的运行依赖`Session ID`，而 `Session ID` 是存在 `Cookie` 中的，也就是说，如果浏览器禁用了 `Cookie`，`Session` 也会失效（但是可以通过其它方式实现，比如在 `url` 中传递 `Session ID`）。



##  日期格式

打印出前六个月的时间格式例如 2018-3-22 22:21:21。

```php
$date = date("Y-n-d H:i:s", strtotime("-6 month"));
```

```php
date("Y-m-d",time());       //显示格式如 2018-12-01
date("Y.m.d",time());       //显示格式如 2018.12.01
date("M d Y",time());       //显示格式如 Dec 01 2018
date("Y-m-d H:i",time());   //显示格式如 2018-12-01 12:01
```



# 高并发大流量解决方案

## 基础术语

* `PV`：`Page View`，页面浏览量或点击量，用户每一次对网站中的每个网页访问均被记录一次。用户对同一页面的多次访问，访问量累计。
* `UV`：`Unique Visitor`，独立访客。访问网站的一台电脑客户端为一个访客。同一天内相同的客户端只被计算一次。
* `IP`：`Internet Protocol`，指独立`IP`数。同一天内相同`IP`地址只被计算一次。
* `高并发`：是指可以让软件系统在一段时间内能够处理大量的请求。比如每秒钟可以完成10万个请求。通常如果一个系统的日`PV`在千万以上，就有可能是一个高并发的系统。
* `QPS`：`Queries Per Second`意思是每秒响应请求数，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。峰值每秒请求数（`QPS`）=（总 `PV` 数 * 80%）/（6小时秒数 * 20%），80%的访问量集中在20%的时间。
* `TPS`：`Transactions Per Second`意思是每秒事务数。每秒钟系统能够处理事务或交易的数量，它是衡量系统处理能力的重要指标。
* `吞吐量`：单位时间内处理的请求数量（通常由`QPS`与并发数决定）。
* `吞吐率`：单位时间内网络上传输的数据量，也可以指单位时间内处理客户请求数量。它是衡量网络性能的重要指标。通常情况下，吞吐率 “字节数/秒” 来衡量。
* `网络带宽`：网络带宽是指在单位时间（一般指的是1秒钟）内能传输的数据量。网络和高速公路类似，带宽越大，就类似高速公路的车道越多，其通行能力越强。计算带宽大小需要关注两个指标，峰值流量和页面的平均大小。日网站带宽 = PV / 统计时间（秒）* 平均页面大小（单位KB）* 8 。
* `并发连接数`：系统同时处理的请求数。不同于`QPS`是每秒的`HTTP`请求数量。







## 优化概览

高并发大流量解决方案的优化思路：

* 流量优化：例如防盗链。
* 前端优化：一是页面级优化，减少HTTP的请求（合理设置 HTTP缓存，启用浏览器缓存和静态资源过期时间缓存， CSS、 Javascript、Image 资源合并与压缩，使用异步请求）；二是代码级别的优化（Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化）；三是合理使用`CDN`加速。
* 服务端优化：动态语言静态化、图片服务器与`WEB`服务器分离、并发处理、消息队列处理
* 缓存层优化：数据库缓存（`Memcached`、`Redis`、`MongoDB`）
* MySQL优化：分库分表、分区操作、读写分离
* 数据库架构优化：
* 服务器优化：负载均衡（Nginx的反向代理）
* 架构层面优化：从架构上来说，采用前后端分离的分层架构，前端负责站点展现层（异步获取数据，响应速度提升），后端负责站点数据层（通过内网一次性返数据，性能大幅度提升）。

## 流量优化

### 防盗链

[OSS实现网站的防盗链？](https://developer.aliyun.com/article/57931)

盗链：在自己的页面上展示一些并不在自己服务器上的资源（图片、视频、音乐、软件等）。通过获得他人服务器上的资源地址，绕过别人的资源进行展示页面。

方法一：**nginx配置方式防盗链**

```nginx
location ~* ^.*\.(gif|jpg|png|swf|flv|rar|zip|doc|pdf|gz|bz2|jpeg|bmp|xls)$
{
         valid_referers none blocked server_names  *.wwxiong.com  ~\.google\. ~\.baidu\. ;
         if ($invalid_referer) {
              return 403;
              # rewrite ^/ http://xxx/xxx/404.jpg;
          }
}
```

原理：该指令会根据`Referer Header`头的内容分配一个值为0或1给全局变量`$invalid_referer`，默认值为`none`。如果`Referer Header`头不符合`valid_referers`指令设置的有效`Referer`，将被设置为1。

> `none`：表示无`Referer`值的情况。
> `blocked`：表示`Referer`值被防火墙进行伪装。
> `server_names`：表示一个或多个主机名称。

## 前端优化

### 减少 HTTP 请求

>  性能黄金法则：只有10%-20%的最终用户响应时间花在接收所请求的 HTML 文档上。剩下的80%0-90%时间花在了为 HTML 文档所引用的所有组件（图片、脚本、样式表、Flash 等）进行的 HTTP 请求上。

解决办法：改善响应时间的最简单途径就是减少组件的数量，并由此减少 `HTTP` 请求的数量。

* 使用图片地图，图片地图允许你在一个图片上关联多个 `URL`，目标`URL`的选择取决于用户单击了图片上的哪个位置。
* 使用`CSS Sprites`（`css`精灵），它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。
* 图片优化，使用`Base64`编码减少页面请求数（采用`Base64`的编码方式将图片直接嵌入到网页中，而不是从外部载入）；图片密集型网站可使用图片懒加载。
* 合并压缩`css`样式表和`js`脚本，目的是为了减少 `HTTP` 请求的数量。

### 浏览器静态缓存

对一个网站而言，`CSS`、`JavaScript`、图片等这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次`Http`请求都需要的，如果将这些文件缓存在浏览器中，可以极好的改善性能。

缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。

对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

`Nginx`静态资源缓存配置策略：

```nginx
server {
    listen       80 default_server;
    server_name  www.wwxiong.com;
    root         /app/xxx/html/mobile/;

    location ~ .*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$
    {
        expires      7d;
    }

    location ~ .*\.(?:js|css)$
    {
        expires      7d;
    }

    location ~ .*\.(?:htm|html)$
    {
        add_header Cache-Control "private, no-store, no-cache, must-revalidate, proxy-revalidate";
    }
}  
```

### 数据文件压缩

* `JavaScript` 代码的压缩：去掉多余的空格和回车、替换长变量名、简化代码写法，`script`标签放在底部，不要放在`head`标签。

* `CSS `代码的压缩：避免使用`CSS`表达式，`CSS`语义合并，删除无效的字符、代码、注释，代码语义的缩减和优化。

* `HTML` 代码的压缩：删除无用的字符，空格、换行符、制表符等；删除多余的`html`注释。

* `GZIP` 压缩：开启`gzip`目的是缩短浏览器和服务器之间传送数据的时间，减少带宽的占用，同时提升网站速度。



`Nginx`实现`gzip`压缩配置：

```nginx
server{
        listen 80;
        server_name wwxiong.com;

        gzip on;
        gzip_buffers 32 4k;
        gzip_comp_level 6;
        gzip_min_length 200;
        gzip_types application/javascript application/x-javascript text/javascript text/xml text/css;
        gzip_vary off;
}
```



### 使用 CDN 加速



#### 什么是 CDN?

`CDN`的全称是`Content Delivery Network`，即内容分发网络。它是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。



#### CDN 的优势

* 加速网站的访问。
* 实现跨运营商、跨地域的全网覆盖。

互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。



#### CDN 工作原理

当用户访问已经使用了`CDN`服务的网站时，网站会利用全球负载均衡技术，将用户的访问指向到距离用户最近的正常工作的缓存服务器上，直接响应用户的请求。

其解析过程与传统解析方式的最大区别就在于网站的授权域名服务器不是以传统的轮询方式来响应本地`DNS`的解析请求，而是充分考虑用户发起请求的地点和当时网络的情况，来决定把用户的请求定向到离用户最近同时负载相对较轻的节点缓存服务器上。

通过用户定位算法和服务器健康检测算法综合后的数据，可以将用户的请求就近定向到分布在网络“边缘”的缓存服务器上，保证用户的访问能得到更及时可靠的响应。由于大量的用户访问都由分布在网络边缘的`CDN`节点缓存服务器直接响应了，这就不仅提高了用户的访问质量，同时有效地降低了源服务器的负载压力。

> `CDN`是只对网站的某一个具体的域名加速。如果同一个网站有多个域名，则访客访问加入`CDN`的域名获得加速效果，访问未加入`CDN`的域名，或者直接访问`IP`地址，则无法获得`CDN`效果。



#### CDN 应用场景

适用场景：

* 网站与应用加速。网站或者应用中大量静态资源的加速分发，如各类型图片、`html`、`css`、`js`文件等，可以通过`CDN`缓存到边缘节点上，当用户访问即可就近获取。
* 视频、大文件下载分发加速。`CDN`可以针对各类文件、在线点播视频提供下载、分发加速，比如`mp4`、`flv`视频文件或者单个文件大小在20M以上的安装包等文件。
* 直播加速。`CDN`借助负载均衡系统将将主播端采集的音视频数据推送到接近用户的数千个边缘节点，当观众端发起请求，就可以就近取得资源，减少网络抖动风险，增加直播链路稳定性和流畅性。
* 移动应用加速。`CDN`可以为移动`APP`更新文件（`apk`文件）分发，移动`APP`内图片、页面、短视频、`UGC`等内容的优化提供加速分发效果。



不适用场景：

* 适度的用户性，不适用有针对性、特定性、服务用户数较少的群体。

* 极端本地化用户群，不适用给定地理区域和本地化的用户群。

  

## 服务端优化



### 动态语言静态化

对实时性要求不高的页面，将现有的`php`等动态语言的逻辑代码生成静态`html`文件，用户访问动态脚本重定向到静态`html`文件的过程就叫动态语言静态化。



动态脚本通常会做逻辑计算和数据查询，访问量越大, 服务器压力越大；当访问量大时可能会造成`cpu`负载过高，数据库服务器压力过大，而使用静态化可以减小逻辑处理压力，降低数据库服务器查询压力。



静态化的实现方式：

* 方式一、使用模板引擎，可以使用`smarty`的缓存机制生成静态`html`缓存文件。

* 方式二、使用`ob`（输出缓冲取，`output buffering`）系列的函数。



### 并发处理

* PHP并发编程实践（PHP的Swoole扩展、消息队列、接口的并发请求）

  

##  缓存优化



#### Memcache 



#### Redis

 

## MySQL 优化

优化思路：

* 设计角度：存储引擎的选择、字段类型的选择、表设计（范式设计 `OR` 反范式设计）。
* 自身角度：索引、查询缓存、优化配置。
* 架构角度：主从复制、读写分离、负载均衡。



### 设计角度



####存储引擎的选择

* `InnoDB`支持事务，`MyISAM`不支持事务。`InnoDB`属于事务安全型存储引擎。
* `InnoDB`支持外键，`MyISAM`不支持外键。`InnoDB`支持外键约束、保证数据完整性。

* `InnoDB`支持表、行(默认)级锁，而`MyISAM`支持表级锁。`InnoDB`实现行级锁定，并发性处理较好。针对于并发性，`InnoDB`实现了`MVCC`，多版本并发控制。
* `InnoDB`按照主键顺序存储，`MyISAM`按照插入顺序存储。

* `InnoDB`是聚集索引，使用`B+Tree`作为索引结构，数据与索引使用同一个表空间文件来进行存储。`MyISAM`是非聚集索引，也是使用`B+Tree`作为索引结构，但是索引和数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。

`InnoDB`的优缺点：

> **优点：**支持事务，支持外键，并发量较大，适合大量`update`。
>
> **缺点：**查询数据相对较快，不适合大量的`select`。

`MyISAM`的优缺点：

> **优点**：查询数据相对较快，适合大量的`select`，可以全文索引。
>
> **缺点：**不支持事务，不支持外键，并发量较小，不适合大量`update`。

#### 字段类型的选择

> 规则：能小不要大； 能定不要变；能数值不要字符串。

##### 数值类型

| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| :----------- | :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
| TINYINT      | 1 byte                                   | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |



##### 日期和时间类型

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| TIMESTAMP | 4             | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |

##### 字符串类型

| 类型       | 大小                  | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| CHAR       | 0-255 bytes           | 定长字符串                      |
| VARCHAR    | 0-65535 bytes         | 变长字符串                      |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535 bytes        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |



使用示例：

* `tinyint`（1 byte）、`smallint`（2 byte）、`mediumint`（3 byte）、`int`（4 byte）、`bigint`（8 byte）（既需要考虑空间问题、也需要考虑时间问题）。
* `char`（`md5`、手机号固定类型应使用）、`varchar `。
* `enum` 特定的固定的分类可以使用。

* `IP`地址的存储，可以使用整型存储，`int` `unsigned`。



### 自身角度

#### 索引的优化

* 复合索引的前缀原则

* like 查询%的问题

* 全表扫描优化

* or 条件索引使用情况

* 字符串类型索引失效的问题

  



#### SQL 语句的优化

* limit

* 优化count()

* 优化关联查询

* 优化group by 和distinct



### 架构角度



#### MySQL的读写分离

#### 分区以及分库分表



## 数据库架构优化

#### 主从复制

#### 读写分离

#### 双主热备

#### 负载均衡

* LVS 负载均衡

  

## Web 服务器的负载均衡





# NoSQL

## memcache 和 Redis 的区别





#  WEB 安全攻防实战







# 经典大全

## 自总结

### MySQL 事务及 ACID 特性 
归纳概括总结： 
事务（`Transaction`）是由一组`SQL`语句组成的逻辑处理单元；事务中可能包含一个或多个`SQL`语句，这些语句要么都执行，要么都不执行。事务具有`ACID`属性。

> Atomicity（原子性）:原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。事务是应用中不可再分的最小逻辑执行体。 
> Consistent（一致性）:在事务开始和完成时，数据都必须保持一致状态。 
> Isolation（隔离性）:事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 
> Durable（持久性）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。



### MySQL 三大范式 

总结口诀：

> 设计关系型数据库需要遵守设计规范格式(Normal Format)。 
> 第一范式，1NF，字段的原子性。 字段不可分。
> 第二范式，2NF，消除部分依赖（一张表只有一个目的，一条数据只做一件事情）。 必须有主键，非主键字段完全依赖主键（不能存在部分依赖）。
> 第三范式，3NF，消除传递依赖。非主键字段不能相互依赖。

NF1：字段的原子性就是指字段要达到不可拆分。

> 例如:顾客表(姓名、编号、地址、……)其中`地址`列还可以细分为国家、省、市、区等。 
> 班级表（班级名称，教室，课程时间）其中`课程时间`列还可以细分为开课时间和结课时间。

NF2：所谓的第二范式，首先要满足它是`1NF`，另外还需要包含两部分内容：一是表必须有一个主键；二是非主键字段必须完全依赖于主键，而不能只依赖于主键的一部分。

> 老师排课表（老师姓名、老师性别、班级名称、上课教室、开课时间、结课时间）这张表出现了老师信息和课程信息表，掺杂复杂的关系逻辑。如果老师信息表为主表，课程信息表为非主属性表，需要将非主信息表对主信息表的依赖消除。

NF3：所谓的第三范式，是在满足第一范式（字段的原子性）和第二范式（消除部分依赖）的基础上，再消除传递依赖，也就是非主键字段不能相互依赖。

> 注：理解`2NF`和`3NF`的关键点在于，`2NF`-某字段依赖于主键的一部分，`3NF`-某字段依赖于某个非主键字段。

> 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a-->b-->c 属性之间含有这样的关系，是不符合第三范式的。 
> 老师排课表（老师姓名、老师性别、班级名称、上课教室、开课时间、结课时间）中，有些字段（老师性别）依赖某个字段（老师姓名），另外一些字段（上课教室、开课时间、结课时间）依赖于另一个字段（班级名称），存在传递依赖（于ID）的现象。需要把不同实体的数据拆分成不同的数据表（老师信息表、老师排课表、班级信息表）。

![img](系统知识.assets/39190870.png)



学习高级-电商平台（京东）

阿里P8架构师谈：分布式架构设计(文章合集）

