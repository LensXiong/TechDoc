# 问题列表

[关于复杂度分析的工具有哪些？](#complexity)

## 数组

[为什么很多编程语言中数组都从0开始编号？](#array_index)

[数组和链表的区别？](#array_list)

[数组是如何实现根据下标随机访问数组元素的呢？](#array_random)



# 解答列表

## 数组

<span id="array_index">为什么很多编程语言中数组都从0开始编号？</span>

> 从0开始编号的内存地址公式：a[k]_address = base_address + k * type_size
>
> 从1开始编号的内存地址公式：a[k]_address = base_address + (k-1)*type_size 
>
> 如果从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。这对于极致的效率优化并不是最佳方式。

从数组存储的内存模型上来看，下标最确切的定义应该是偏移（offset）。如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：

```go
a[k]_address = base_address + k * type_size
```

如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：

```go
a[k]_address = base_address + k * type_size
```

对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。

<span id="array_list">数组和链表的区别？</span>

> 链表适合插入、删除，时间复杂度 O(1)；
>
> 数组适合查找，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)，排好序的数组，用二分查找，时间复杂度也是 O(logn)。

专业的解释：数组（`Array`）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

<img src="Algorithm.assets/image-20211127220810368.png" alt="image-20211127220810368" style="zoom:50%;" />



<span id="array_random">数组是如何实现根据下标随机访问数组元素的呢？</span>

> 通过寻址公式，计算内存地址，然后通过地址来访问内存中的元素。
>
> a[i]_address = base_address + i * data_type_size

假设用一个长度为 10 的 int 类型的数组 `int[] a = new int[10]`来举例。如下图所示，计算机会给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。

<img src="Algorithm.assets/image-20211127221129690.png" alt="image-20211127221129690" style="zoom:50%;" />

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

```go
a[i]_address = base_address + i * data_type_size
```

其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。

